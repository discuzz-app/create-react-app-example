{"version":3,"file":"static/js/221.0d23f618.chunk.js","mappings":";4VAoK+D,oBAAXA,SAA0BA,OAAOC,WAAaD,OAAOC,SAAWD,OAAO,qBA6DvD,oBAAXA,SAA0BA,OAAOE,gBAAkBF,OAAOE,cAAgBF,OAAO,6CC/JpHG,EAAmCC,GAAAA,IAAAA,IAAAA,EAAAA,WAUnDD,EAAOE,cACTC,EAAAA,mBAAmBC,EAAK,CACtBC,SAAU,IAAIC,EAAAA,oBAAoBN,EAAOE,cACzCK,2BAAAA,IAIJ,IAqNMC,EAAwB,SAACC,GAC7B,MAAoB,KAAbA,GAAmBA,IAAaC,EAAAA,cAGnCC,EAAAA,SAAmBC,EAAwBC,GAAAA,IAAAA,OAC/CC,EAAAA,IAAI,aAAcF,EAAIG,GAAIF,GAAAA,QAAAA,QACbG,EAAAA,UAAmBJ,EAAAA,EAAAA,GAC3BC,EAAAA,CACHI,QAASC,EAAAA,sBAJE,oCAQTC,EAAAA,SAAgBC,EAAiCP,GAAAA,IAAAA,OACrDC,EAAAA,IAAI,UAAWM,EAAWC,KAAMR,EAAMO,GAAAA,QAAAA,QACzBE,EAAAA,OAAgBF,EAAAA,EAAAA,GACxBP,EAAAA,CACHI,QAASC,EAAAA,sBAJD,oCAQNK,EAAAA,SAAmBX,GAAAA,IAAAA,OACvBE,EAAAA,IAAI,aAAcF,GAAAA,QAAAA,QACLY,EAAAA,UAAmBZ,IAFnB,oCAsLTa,EAAAA,SACJZ,GAAAA,IAEA,IAAMa,EACmB,IAAvBb,EAAMc,MAAMC,YAAAA,EAA2Bf,EAAMc,MAAMd,EAAMc,MAAMC,OAAS,mBACtEF,EAAAA,CACFZ,EAAAA,IAAI,wBAAyBY,GAE7B,IAAMG,EAAYjB,EAAAA,IAAIkB,EA9bJ,QA8bgCJ,GAAAA,OAAAA,QAAAA,QAC5Cf,EAAUkB,EAAW,CAEzBE,QAASC,EAAAA,UAAU,4BAPmD,GAOnD,gEAXF,oCAyBjBC,EAAgB,CACpBC,YAAAA,SAAYrB,GACV,IAAMD,EAAW,CACfG,GAAIF,EAAKE,GACTY,MAAOd,EAAKc,MACZD,SAAUb,EAAKa,SAEfS,IAAKtB,EAAKsB,IACVC,OAAQ,CACNrB,GAAIF,EAAKuB,OAAOrB,IAElBN,SAAUI,EAAKJ,SAEf4B,MAAOxB,EAAKwB,MACZN,QAASlB,EAAKkB,QACdO,OAAQzB,EAAKyB,QAWf,OARIzB,EAAKuB,OAAOG,WAAU3B,EAAIwB,OAAOG,SAAW1B,EAAKuB,OAAOG,UACxD1B,EAAKuB,OAAOI,OAAM5B,EAAIwB,OAAOI,KAAO3B,EAAKuB,OAAOI,MAChD3B,EAAK4B,aAAY7B,EAAI6B,WAAa5B,EAAK4B,YACvC5B,EAAKI,UAASL,EAAIK,QAAUJ,EAAKI,SACjCJ,EAAK6B,YAAW9B,EAAI8B,UAAY7B,EAAK6B,WACrC7B,EAAK8B,YAAW/B,EAAI+B,UAAY9B,EAAK8B,WACrC9B,EAAK+B,YAAWhC,EAAIgC,UAAY/B,EAAK+B,WAElChC,GAETiC,cAAAA,SACEC,EACAC,GAEA,IAAMlC,EAAOiC,EAASjC,KAAKkC,GAErBC,EAAa,CACjBjC,GAAI+B,EAAS/B,GAEbY,MAAOd,EAAKc,MACZD,SAAUb,EAAKa,SAEfS,IAAKtB,EAAKsB,IACVC,OAAQ,CACNrB,GAAIF,EAAKuB,OAAOrB,GAChByB,KAAM3B,EAAKuB,OAAOI,KAClBD,SAAU1B,EAAKuB,OAAOG,UAExB9B,SAAUI,EAAKJ,SAEfsB,QAASlB,EAAKkB,QACdM,MAAOxB,EAAKwB,MACZC,OAAQzB,EAAKyB,OAEbQ,SAAAA,GAcF,OAXIjC,EAAKuB,OAAOG,WAAUS,EAAKZ,OAAOG,SAAW1B,EAAKuB,OAAOG,UACzD1B,EAAKc,MAAMC,OAAS,IACtBoB,EAAKtB,SAAWb,EAAKc,MAAMd,EAAKc,MAAMC,OAAS,IAG7Cf,EAAK4B,aAAYO,EAAKP,WAAa5B,EAAK4B,WAAWQ,UACnDpC,EAAKI,UAAS+B,EAAK/B,QAAUJ,EAAKI,QAAQgC,UAC1CpC,EAAK6B,YAAWM,EAAKN,UAAY7B,EAAK6B,UAAUO,UAChDpC,EAAK8B,YAAWK,EAAKL,UAAY9B,EAAK8B,UAAUM,UAChDpC,EAAK+B,YAAWI,EAAKJ,UAAY/B,EAAK+B,UAAUK,UAE7CD,IAsILE,EAAuB,CAC3BhB,YAAAA,SAAYrB,GACV,IAAMD,EAAW,CACfG,GAAIF,EAAKE,GACTY,MAAOd,EAAKc,MAEZQ,IAAKtB,EAAKsB,IACVC,OAAQ,CACNrB,GAAIF,EAAKuB,OAAOrB,IAElBN,SAAUI,EAAKJ,UAWjB,OARII,EAAKuB,OAAOG,WAAU3B,EAAIwB,OAAOG,SAAW1B,EAAKuB,OAAOG,UACxD1B,EAAKuB,OAAOI,OAAM5B,EAAIwB,OAAOI,KAAO3B,EAAKuB,OAAOI,MAEhD3B,EAAKsC,SAAQvC,EAAIuC,OAAStC,EAAKsC,QAC/BtC,EAAK6B,YAAW9B,EAAI8B,UAAY7B,EAAK6B,WACrC7B,EAAK8B,YAAW/B,EAAI+B,UAAY9B,EAAK8B,WACrC9B,EAAK+B,YAAWhC,EAAIgC,UAAY/B,EAAK+B,WAElChC,GAETiC,cAAAA,SACEC,EACAC,GAEA,IAAMlC,EAAOiC,EAASjC,KAAKkC,GAErBC,EAAoB,CACxBjC,GAAI+B,EAAS/B,GAEbY,MAAOd,EAAKc,MAEZQ,IAAKtB,EAAKsB,IACVC,OAAQ,CACNrB,GAAIF,EAAKuB,OAAOrB,GAChByB,KAAM3B,EAAKuB,OAAOI,KAClBD,SAAU1B,EAAKuB,OAAOG,UAExB9B,SAAUI,EAAKJ,UAYjB,OATII,EAAKuB,OAAOG,WAAUS,EAAKZ,OAAOG,SAAW1B,EAAKuB,OAAOG,UACzD1B,EAAKc,MAAMC,OAAS,IACtBoB,EAAKtB,SAAWb,EAAKc,MAAMd,EAAKc,MAAMC,OAAS,IAE7Cf,EAAKsC,SAAQH,EAAKG,OAAStC,EAAKsC,QAChCtC,EAAK6B,YAAWM,EAAKN,UAAY7B,EAAK6B,UAAUO,UAChDpC,EAAK8B,YAAWK,EAAKL,UAAY9B,EAAK8B,UAAUM,UAChDpC,EAAK+B,YAAWI,EAAKJ,UAAY/B,EAAK+B,UAAUK,UAE7CD,IAKX,MAAO,CACLI,aA1rB8B,SAACrC,GAC/B,MAAwBsC,EAAAA,SAAsB,MAAvCL,EAAAA,EAAAA,GAAMM,EAAAA,EAAAA,GAAAA,EACuBD,EAAAA,SAClCE,EAAAA,aAAaC,SADRC,EAAAA,EAAAA,GAAYC,EAAAA,EAAAA,GAIbC,EAAaC,EAAAA,aACjB,SAACC,GACCP,EAAQO,EAAShD,QACjB6C,EAAcH,EAAAA,aAAaO,WAE7B,CAACR,EAASI,IAeZ,OAZAK,EAAAA,WAAU,WACR,IAAMC,EAAYpD,EAAAA,IAAIkB,EAtCJ,QAsCgCf,GAAIkD,cACpDhC,GAOF,OAJAyB,EAAcH,EAAAA,aAAaW,SAEFC,EAAAA,WAAWH,EAAWL,KAG9C,CAAC5C,IAEG,CACLiC,KAAAA,EACAS,WAAAA,IA+pBFW,iBA3pBsC,SACtCjC,EACAkC,EACAC,QAAAA,IAAAA,IAAAA,EAAsB,MAEtB,MAA0BC,EAAAA,SAAiB,IAApCC,EAAAA,EAAAA,GAAOC,EAAAA,EAAAA,GAAAA,EACsBpB,EAAAA,SAClCE,EAAAA,aAAaC,SADRC,EAAAA,EAAAA,GAAYC,EAAAA,EAAAA,GAAAA,EAGsBL,EAAAA,UAAAA,GAAlCqB,EAAAA,EAAAA,GAAcC,EAAAA,EAAAA,GAAAA,EACiBtB,EAAAA,SAAkC,MAAjEuB,EAAAA,EAAAA,GAAaC,EAAAA,EAAAA,GAAAA,EACQxB,EAAAA,SAAkC,MAAvDyB,EAAAA,EAAAA,GAAQC,EAAAA,EAAAA,GAETC,EAAiBpB,EAAAA,aAAY,SAACqB,GAClC,IAAMC,EAAmB,GAUzB,OARAD,EAAUE,SAAQ,SAACC,GACjB,IAAMvE,EAAOuE,EAAQvE,OAEjBA,EAAK6B,WACPwC,EAASG,KAAKxE,MAIXqE,IACN,IAEGI,EAAsB1B,EAAAA,aAC1B,SAACqB,GACC,IAAMC,EAAWF,EAAeC,GAEhCnE,EAAAA,IAAI,yBAA0BoE,GAC9BT,GAAS,SAACc,GACR,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAAStD,OAAQ4D,IACnCD,EAAMF,KAAKH,EAASM,OAIxB9B,EAAcH,EAAAA,aAAaO,SAEzBa,IADEO,EAAStD,OAASyC,MAMxB,CAACI,EAAUO,EAAgBtB,IAEvB+B,EAA4B7B,EAAAA,aAChC,SAACqB,GACC,IAAMC,EAAWF,EAAeC,GAEhCnE,EAAAA,IAAI,wBAAyBoE,GAC7BT,GAAS,SAACc,GACR,mBAASC,GACP,IAAME,EAAUR,EAASM,GACnBG,EAAQJ,EAAMK,WAAU,SAAC5C,GAAAA,OAASA,EAAKjC,KAAO2E,EAAQ3E,OAE7C,IAAX4E,GACF7E,EAAAA,IAAI,oBAAqB4E,EAAQ3E,GAAI2E,GACrCH,EAAMM,QAAQH,KAEd5E,EAAAA,IAAI,wBAAyB4E,EAAQ3E,GAAI2E,GACzCH,EAAMI,GAASD,IATVF,EAAIN,EAAStD,OAAS,EAAG4D,GAAK,EAAGA,IAAAA,EAAjCA,QAcb,CAACf,EAAUO,IAEbjB,EAAAA,WAAU,WACJS,EAAM5C,OAAS,GAAK4C,EAAMA,EAAM5C,OAAS,GAAGc,YAE5B,OAAhBkC,GACAA,EAAY7D,KAAOyD,EAAMA,EAAM5C,OAAS,GAAGb,IAE3C8D,EAAeL,EAAMA,EAAM5C,OAAS,GAAGkB,aAG1C,CAAC0B,EAAOI,IAEXb,EAAAA,WAAU,WACR,GAAe,OAAXO,GAAmBA,EAAOvC,QAAU,EAAG,CACzC,IAAM+D,EAAmB,CACvBC,EAAAA,MAAM,MAAO,KAAM5D,GACnB4D,EAAAA,MAAM,WAAY,KAAMzB,EAASA,EAAOvD,GAAK,MAC7CiF,EAAAA,QAAQ,YAAa,QACrBC,EAAAA,MAAM5B,IAGO,OAAXS,GACFgB,EAAUT,KAAKa,EAAAA,WAAWpB,IAG5BpB,EAAcH,EAAAA,aAAaW,SAG3B,IAAMiC,EAAaC,EAAAA,MAAAA,WAAAA,EAAAA,CACjBhF,EAAAA,WAAWU,EAxJG,iBAyJXgE,IACH7B,cAAchC,GAEhBoE,EAAAA,QAAQF,GACLG,KAAKhB,GACLiB,OAAM,SAACC,GACNC,EAAAA,MAAM,oBAAqBD,GAC3B9C,EAAcH,EAAAA,aAAamD,cAEH,IAAnBpC,EAAOvC,SAChB2B,EAAcH,EAAAA,aAAaO,WAE5B,CAAC3B,EAAKmC,EAAQQ,EAAQQ,EAAqB5B,IAE9CK,EAAAA,WAAU,WACR,GAAIN,IAAeF,EAAAA,aAAaO,SACT,IAAjBU,EAAM5C,OAAc,CACtB,IAAMkE,EAAmB,CACvBC,EAAAA,MAAM,MAAO,KAAM5D,GACnB4D,EAAAA,MAAM,WAAY,KAAMzB,EAASA,EAAOvD,GAAK,MAC7CgF,EAAAA,MAAM,UAAW,IAAK,IAAIY,MAC1BX,EAAAA,QAAQ,UAAW,SAGfY,EAAiBR,EAAAA,MAAAA,WAAAA,EAAAA,CACrBhF,EAAAA,WAAWU,EAlLC,iBAmLTgE,IACH7B,cAAchC,GAOhB,OALyBkC,EAAAA,WACvByC,EACAnB,GAMN,sBAGC,CAAChC,EAAYe,IAEhBT,EAAAA,WAAU,WACR,GAAIa,EAAa,CACf,IAAMkB,EAAmB,CACvBC,EAAAA,MAAM,MAAO,KAAM5D,GACnB4D,EAAAA,MAAM,WAAY,KAAMzB,EAASA,EAAOvD,GAAK,MAC7CgF,EAAAA,MAAM,UAAW,IAAK,IAAIY,MAC1BX,EAAAA,QAAQ,UAAW,QACnBa,EAAAA,MAAMjC,IAGFgC,EAAiBR,EAAAA,MAAAA,WAAAA,EAAAA,CACrBhF,EAAAA,WAAWU,EA9MG,iBA+MXgE,IACH7B,cAAchC,GAOhB,OALyBkC,EAAAA,WACvByC,EACAnB,GAKJ,sBAGC,CAACtD,EAAKmC,EAAQM,EAAaa,IAE9B,IAAMqB,EAAWlD,EAAAA,aAAY,WACvBY,EAAM5C,OAAS,GACjBmD,EAAUP,EAAMA,EAAM5C,OAAS,GAAGkB,YAEnC,CAAC0B,EAAOO,IAEX,MAAO,CACLP,MAAAA,EACAsC,SAAAA,EACAC,QAAoB,OAAXzC,EAAkBI,EAAeJ,EAAOvC,QAAUyC,EAAM5C,OACjE6B,WAAAA,IA2eFuD,kBA9cwC,WACxC,MAAoCC,EAAAA,UAA5BC,EAAAA,EAAAA,KAAMC,EAAAA,EAAAA,kBA+Dd,OA7DgBvD,EAAAA,aAAAA,SACPnD,EAAkB0B,EAAcmC,GAAAA,IAAAA,IAAAA,EAAAA,WAWrC,IAAMzD,EAAY,CAChBc,MAAO2C,EAAAA,GAAAA,OAAaA,EAAO3C,MAAAA,CAAO2C,EAAOvD,KAAM,GAC/CW,SAAU4C,EAASA,EAAOvD,GAAK,KAE/BoB,IAAKmC,EAASA,EAAOnC,IAAMA,EAC3BC,OAAQ,CACNrB,GAAIqG,EAAaC,IACjB7E,KAAM4E,EAAaE,YACnB/E,SAAU6E,EAAaG,UAAY,IAErC9G,SAAAA,EAEAiC,UAAWxB,EAAAA,mBAAAA,GAGTkG,EAAaI,YAAAA,CAAAA,IAAAA,EACTC,EAAAA,EAAAA,GACD5G,EAAAA,CAEHwB,MAAO,EACPN,QAAS,EACTO,QAAAA,EAAAA,GAAAA,EACG8E,EAAaC,KAAM,KAItB5E,WAAYvB,EAAAA,oBAAAA,OAGdJ,EAAAA,IAAI,oBAAqB2G,GAAAA,QAAAA,QAEnBtG,EAAOC,EAAAA,WAAWU,EAnTV,SAmTuC2F,IAAAA,MAAAA,WAAAA,OAAAA,QAAAA,QAE/ChG,EAAkBgG,IAAAA,MAAAA,WAExB,OAAOC,EAAAA,iBAAiBC,cAExB,IAAMF,EAAAA,EAAAA,GACD5G,GAAAA,OAAAA,QAAAA,QAGCM,EAAOC,EAAAA,WAAWU,EA9TF,iBA8TuC2F,IAAAA,MAAAA,WAE7D,OAAOC,EAAAA,iBAAiBE,YArD1B,GAAIpH,EAAsBC,GACxB,OAAO,QAAP,QAAOiH,EAAAA,iBAAiBG,SAG1B,IAAIT,EAAqBF,EAAAA,EAAAA,WAAAA,GAErBE,IAAiBA,EAAaC,IAAAA,OAAAA,QAAAA,QACXF,KAAAA,MAAAA,SAAAA,GAArBC,EAAAA,KAHuBF,GAGvBE,OAAAA,QAAAA,QAAAA,GAAAA,EAAAA,KAAAA,EAAAA,KAAAA,GAAAA,KATqB,qCA0DzB,CAACD,EAAmBD,KAkZtBY,mBA5Y0C,WAC1C,IAAQZ,EAASD,EAAAA,UAATC,KA8CR,OA5CiBtD,EAAAA,aAAAA,SACRZ,EAAYvC,GAAAA,IACjB,GAAID,EAAsBC,GACxB,OAAO,QAAP,QAAOiH,EAAAA,iBAAiBG,SAG1B,IAAMhH,EAAY,CAChBJ,SAAUA,EACVkC,UAAWzB,EAAAA,mBAGb,GAAIgG,EAAMM,YAAa,CACrB,IAAMpC,EAAUxE,EAAAA,IAAIkB,EAvVN,QAuVmCkB,EAAKjC,IAEhD0G,EAAAA,EAAAA,GACD5G,GAJgB,uBAQfF,EAAUyE,EAASqC,IAAAA,MAAAA,WAEzB,OAAOC,EAAAA,iBAAiBC,WAExB,IAAMF,EAAAA,EAAAA,GACD5G,EAAAA,CACHsC,OAAQH,EAAKjC,GAEbY,MAAO,GACPD,SAAU,KACVU,OAAQ,CACNrB,GAAImG,EAAMG,IACV7E,KAAM,GACND,SAAU,MAVT,uBAcCpB,EAAOC,EAAAA,WAAWU,EAhXF,iBAgXuC2F,IAAAA,MAAAA,WAE7D,OAAOC,EAAAA,iBAAiBE,WAtCF,qCAyC1B,CAACV,KAiWHa,qBA3V8C,WAgB9C,OAfmBnE,EAAAA,aAAAA,SACVZ,GAAAA,IACL,IAAMoC,EAAUxE,EAAAA,IAAIkB,EA7XJ,QA6XgCkB,EAAKjC,IAAAA,OAAAA,QAAAA,QAE/CJ,EAAUyE,EAAS,CACvB3E,SAAU,GAEVmC,UAAW1B,EAAAA,qBAAAA,MAAAA,WAGb,OAAOwG,EAAAA,iBAAiBC,WAVE,qCAY5B,KA+UFK,yBAzUsD,WACtD,MAAyBf,EAAAA,UAAjBC,EAAAA,EAAAA,KAAMe,EAAAA,EAAAA,OAqCd,OAnCuBrE,EAAAA,aAAAA,SACdZ,GAAAA,IACL,GAAIkE,MAAAA,GAAAA,EAAMgB,cAAe,kBAuBvB,OAAOR,EAAAA,iBAAiBC,SAtBxB7G,EAAAA,IAAI,cAAekC,EAAKjC,GAAI,SAAUiC,EAAKV,OAAQ,OAAQ4E,EAAKG,KAEhE,IAAMjC,EAAUxE,EAAAA,IAAIkB,EArZN,QAqZkCkB,EAAKjC,IAAAA,EAEjDiC,EAAKV,OAAO4E,EAAMG,MACpBvG,EAAAA,IAAI,cAAeoG,EAAKG,KAAAA,QAAAA,QAElB1G,EAAUyE,GAAAA,EAAAA,GAAAA,EAAAA,UACH8B,EAAKG,KAAQc,EAAAA,cAAAA,EAExB9F,MAAOL,EAAAA,WAAW,+BAGpBlB,EAAAA,IAAI,WAAYoG,EAAKG,KAAAA,QAAAA,QAEf1G,EAAUyE,GAAAA,EAAAA,GAAAA,EAAAA,UACH8B,EAAKG,KAAQ,IAExBhF,MAAOL,EAAAA,UAAU,8EAQrB,OAFAiG,IAAAA,QAAAA,QAEOP,EAAAA,iBAAiBG,SA7BI,4CAgChC,CAACX,KAuSHkB,oBA5LgD,WAChD,IAAQlB,EAASD,EAAAA,UAATC,KAAAA,EACkB7D,EAAAA,SAAwB,IAA3CmB,EAAAA,EAAAA,GAAOC,EAAAA,EAAAA,GAER4D,EAAczE,EAAAA,aAClB,SAACqB,GACC,IAAMT,EAAuB,GAE7BS,EAAUE,SAAQ,SAACC,GACjBZ,EAAMa,KAAKD,EAAQvE,WAGrB4D,EAASD,KAEX,CAACC,IAmBH,OAhBAV,EAAAA,WAAU,WACR,GAAImD,GAAQA,EAAKoB,QAAS,CACxB,IAAMnC,EAAaC,EAAAA,MACjBhF,EAAAA,WAAWU,EAhjBW,kBAijBtBmC,cAAcf,GAKhB,OAHAmD,EAAAA,QAAQF,GAAYG,KAAK+B,GAAa9B,MAAMgC,QAAQ/B,OAC3BrC,EAAAA,WAAWgC,EAAYkC,GAIlD,sBAGC,CAACnB,EAAMmB,IAEH,CAAEG,aAAchE,IA4JvBiE,0BArJwD,WACxD,MAAiBxB,EAAAA,UAmBjB,OAjBwBrD,EAAAA,aAAAA,SACf8E,EAA0BjI,GAAAA,IAC/B,GAT+B,SAACA,GACpC,OAAQA,GAAYA,IAAaC,EAAAA,aADE,CASED,GAC/B,OAAO,QAAP,QAAOkI,EAAAA,wBAAwBjC,MAGjC,IAAMtB,EAAUxE,EAAAA,IAAIkB,EA7kBI,gBA6kBgC4G,EAAY3H,IAAAA,OAAAA,QAAAA,QAC9DJ,EAAUyE,EAAS,CACvB3E,SAAAA,EACAkC,UAAWzB,EAAAA,qBAAAA,MAAAA,WAGb,OAAOyH,EAAAA,wBAAwB7E,WAZA,qCAcjC,CAAC,EAhBKoD,QAqJR0B,4BAhI4D,WAC5D,MAAiB3B,EAAAA,UAYjB,OAV0BrD,EAAAA,aAAAA,SACjB8E,GAAAA,IACL,IAAMtD,EAAUxE,EAAAA,IAAIkB,EA/lBI,gBA+lBgC4G,EAAY3H,IAAAA,OAAAA,QAAAA,QAC9DQ,EAAU6D,IAAAA,MAAAA,WAEhB,OAAOuD,EAAAA,wBAAwB7E,WALE,qCAOnC,CAAC,EATKoD,QAgIR2B,6BAlH8D,WAC9D,MAAiB5B,EAAAA,UA2CjB,OAzC2BrD,EAAAA,aAAAA,SAClB8E,GAAAA,IACL,IAAMI,EAAiBlI,EAAAA,IACrBkB,EA/mBsB,gBAinBtB4G,EAAY3H,IAAAA,OAAAA,QAAAA,QAEKgI,EAAAA,OAAOD,IAAAA,MAAAA,SAApB9F,GAAAA,SAAAA,IAAAA,OAAAA,QAAAA,QA2BAzB,EAAUuH,IAAAA,MAAAA,WAEhB,OAAOH,EAAAA,wBAAwB7E,WA5B/B,IAAMjD,EAAY,CAChB4B,WAAYvB,EAAAA,kBACZD,QAASC,EAAAA,mBAGLuG,EAAWzE,EAAKnC,OAAAA,EAAAA,WAAAA,GAClB6H,EAAYvF,OAAAA,CACd,IAAMiC,EAAUxE,EAAAA,IAAIkB,EA1nBN,QA0nBkC4G,EAAYvF,QAAAA,OAAAA,QAAAA,QACtDxC,EAAUyE,EAAAA,EAAAA,GACXvE,EAAAA,CACHJ,SAAUgH,EAAUhH,SACpBkC,UAAW8E,EAAU9E,cAAAA,MAAAA,eAAAA,IAAAA,EAAAA,OAAAA,QAAAA,QAGjBxB,EAAOC,EAAAA,WAAWU,EAjoBV,cAkoBT2F,EACA5G,EAAAA,CACHkB,QAAS,EACTM,MAAO,EACPC,QAAAA,EAAAA,GAAAA,EACGmF,EAAUrF,OAAOrB,IAAK,0BAI3BU,EAAkBgG,MAnBE5G,GAmBF4G,OAAAA,GAAAA,EAAAA,KAAAA,EAAAA,KAAAA,GAAAA,OAhCc,qCAsCpC,CAAC,EAxCKP,UAlmBJ9G,EAAMH,EAAKY,KAAKT,IAChB0B,EAAYkH,EAAAA,aAAa5I,GAAAA,EAAAA,SD8eV6I,EAAMC,GAC5B,IACC,IAAIC,EAAAA,QAAAA,QC7eIC,EAAAA,2BAA2BtH,IAAAA,MAAAA,eD8elC,MAAMuH,GACP,OAAOH,EAAQG,GAEhB,OAAIF,GAAUA,EAAO7C,KACb6C,EAAO7C,UAAAA,EAAa4C,GAErBC,ECvfyB/I,CDufzB+I,GAAAA,SCnfG3C,GACP+B,QAAQ/B,MAAM,0BAA2BA,MAAAA,OAAAA,QAAAA,QAAAA,GAAAA,EAAAA,KAAAA,EAAAA,KAAAA,GAAAA,KAP7C,MAAA6C,GAAA,sBAAAA,2cCjBMC,EAAmB,IAAIC,IAChBC,EAA+B,CAC1CC,WAAW,EACXC,eAAgB,IAGZC,EAA0B,CAC9BC,aAAa,EACbC,SAAS,YAGKC,EAAS1J,GACvB,OAAOkJ,EAAiBS,IAAI3J,IAAQoJ,WAGtBQ,EAAS5J,EAAkB6J,GACzCX,EAAiBY,IAAI9J,EAAK6J,YAWZE,IACd,OAAOR,EC7DF,IAAMS,EACX,yDAOWC,EAUO,IAVPA,EAcO,KCbPC,EAAA,WAGX,WACmBC,EACAC,EACAC,EACAC,EACAC,GAIjB,IAJmC,eAJlB,KAAAJ,UAAAA,EACA,KAAAC,YAAAA,EACA,KAAAC,gBAAAA,EACA,KAAAC,WAAAA,EACA,KAAAC,WAAAA,EAPX,KAAAC,QAAoC,KAS1CC,KAAKC,sBAAwBJ,EAEzBA,EAAaC,EACf,MAAM,IAAII,MACR,+FAKN,WACEF,KAAKC,sBAAwBD,KAAKH,WAClCG,KAAKG,SAAQ,GAAMzE,OAAM,mCAK3B,WACMsE,KAAKD,UACPC,KAAKD,QAAQK,OAAO,aACpBJ,KAAKD,QAAU,+BAInB,WACE,QAASC,KAAKD,gEAGR,WAAcM,GAAd,sEACNL,KAAKM,OADC,SAGJN,KAAKD,QAAU,IAAI,KAHf,SAIEQ,EAAMP,KAAKQ,WAAWH,IAJxB,cAWJL,KAAKD,QAAQU,UAXT,SAYET,KAAKD,QAAQW,QAZf,cAaJV,KAAKD,QAAU,IAAI,KAbf,UAcEC,KAAKN,YAdP,eAgBJM,KAAKD,QAAQU,UAhBT,UAiBET,KAAKD,QAAQW,QAjBf,QAmBJV,KAAKG,SAAQ,GAAMzE,OAAM,eAnBrB,kDAuBAsE,KAAKL,YAAL,MACFK,KAAKG,SAAQ,GAAOzE,OAAM,eAI1BsE,KAAKM,OA5BH,yIAiCA,SAAWD,GACjB,GAAIA,EAKF,OAFAL,KAAKC,sBAAwBD,KAAKH,WAE3BG,KAAKJ,kBAGZ,IAAMe,EAA2BX,KAAKC,sBAOtC,OALAD,KAAKC,uBAAyB,EAE1BD,KAAKC,sBAAwBD,KAAKF,aACpCE,KAAKC,sBAAwBD,KAAKF,YAE7Ba,QAtFA,GA2Fb,SAASJ,EAAMK,GACb,OAAO,IAAIC,SAAc,SAAAJ,GACvBK,WAAWL,EAASG,MCtFxB,IAAMG,GAAM,eACV,sBACE,8PAFQ,SAMV,wBACE,sKAPQ,SASV,sBACE,8GAVQ,SAYV,oBACE,oFAbQ,SAeV,qBACE,4EAhBQ,SAiBV,eACE,gFAlBQ,SAmBV,cACE,qFApBQ,SAqBV,cACE,mFAtBQ,SAuBV,kBAAiC,qBAvBvB,SAwBV,YAxBU,0FAuCCC,EAAgB,IAAI,KAC/B,WACA,WACAD,YCpDcE,IACe,MAA7BC,EAA6B,wDAE7B,OAAIA,EACoB,QAAf,EAAAC,KAAKC,kBAAU,eAAEC,WAEnBF,KAAKC,oBAGEE,EAAgB/L,GAC9B,IAAK0J,EAAS1J,GAAKqJ,UACjB,MAAMoC,EAAcO,OAAM,wBAAsC,CAC9DC,QAASjM,EAAIoC,gBAQH8J,IACd,MAAO,uCAAuCC,QAAQ,SAAS,SAAAC,GAC7D,IAAMC,EAAqB,GAAhBC,KAAKC,SAAiB,EAEjC,OADY,MAANH,EAAYC,EAAS,EAAJA,EAAW,GACzBG,SAAS,gBAINC,EAAkBC,GAChC,IAAMC,EAAeL,KAAKM,MAAMF,EAAmB,KAC7CG,EAAOP,KAAKQ,MAAMH,EAAe,OACjCI,EAAQT,KAAKQ,OAAOH,EAAsB,KAAPE,EAAc,IAAM,MACvDG,EAAUV,KAAKQ,OAClBH,EAAsB,KAAPE,EAAc,GAAa,KAARE,GAAgB,IAE/CE,EAAUN,EAAsB,KAAPE,EAAc,GAAa,KAARE,EAAyB,GAAVC,EAE7DjE,EAAS,GAQb,OAPI8D,IACF9D,GAAUmE,EAAIL,GAAQ,MAEpBE,IACFhE,GAAUmE,EAAIH,GAAS,MAEzBhE,GAAUmE,EAAIF,GAAW,KAAOE,EAAID,GAAW,IAIjD,SAASC,EAAIC,GACX,OAAc,IAAVA,EACK,KAEFA,GAAS,GAAKA,EAAMX,WAAa,IAAMW,WChC1BC,EAAc,EAAd,wEAAf,aAELC,GAFK,8FACHtL,EADG,EACHA,IAAK8G,EADF,EACEA,KAGDyE,EAAuB,CAC3B,eAAgB,qBAGZC,EAAiBF,EAAuBG,aAAa,CACzDC,UAAU,OAGVH,EAAQ,qBAAuBC,EAAeG,yBAE1C/K,EAAuB,CAC3BgL,OAAQ,OACR9E,KAAM+E,KAAKC,UAAUhF,GACrByE,QAAAA,GAjBG,kBAqBcQ,MAAM/L,EAAKY,GArBzB,OAqBHoL,EArBG,+DAuBGtC,EAAcO,OAAM,sBAAoC,CAC5DgC,qBAAsB,KAAcC,UAxBnC,WA4BmB,MAApBF,EAASG,OA5BR,uBA6BGzC,EAAcO,OAAM,qBAAmC,CAC3DmC,WAAYJ,EAASG,SA9BpB,mCAqCkBH,EAASK,OArC3B,QAqCHC,EArCG,gEAuCG5C,EAAcO,OAAM,oBAAkC,CAC1DgC,qBAAsB,KAAcC,UAxCnC,YA8CCK,EAAQD,EAAaE,IAAID,MAAM,mBACtBA,EAAM,KAAME,MAAMC,OAAOH,EAAM,KA/CzC,uBAgDG7C,EAAcO,OAAM,oBAAkC,CAC1DgC,qBACE,iFACWK,EAAaE,OAnDzB,eAsDCG,EAAwC,IAAnBD,OAAOH,EAAM,IAElCK,EAAMpI,KAAKoI,MAxDZ,kBAyDE,CACLC,MAAOP,EAAaQ,iBACpBC,iBAAkBH,EAAMD,EACxBK,mBAAoBJ,IA5DjB,kGAgESK,EACdhP,EACAiP,GAEA,MAAqCjP,EAAI2C,QAAjCuM,EAAR,EAAQA,UAAWC,EAAnB,EAAmBA,MAAOC,EAA1B,EAA0BA,OAE1B,MAAO,CACLrN,IAAK,GAAF,OAAKiI,EAAL,qBAA+BkF,EAA/B,iBAAiDC,EAAjD,YJ9FwC,yBI8FxC,gBAAiGC,GACpGvG,KAAM,CACJ,gBAAmBoG,aAKTI,EACdrP,EACAiP,GAEA,MAAqCjP,EAAI2C,QAAjCuM,EAAR,EAAQA,UAAWC,EAAnB,EAAmBA,MAAOC,EAA1B,EAA0BA,OAE1B,MAAO,CACLrN,IAAK,GAAF,OAAKiI,EAAL,qBAA+BkF,EAA/B,iBAAiDC,EAAjD,YJ1GL,mCI0GK,gBAA4GC,GAC/GvG,KAAM,CACJ,2BAA8BoG,aAKpBK,EACdtP,EACAuP,GAEA,MAAqCvP,EAAI2C,QAAjCuM,EAAR,EAAQA,UAAWC,EAAnB,EAAmBA,MAAOC,EAA1B,EAA0BA,OAE1B,MAAO,CACLrN,IAAK,GAAF,OAAKiI,EAAL,qBAA+BkF,EAA/B,iBAAiDC,EAAjD,YJvHoC,qBIuHpC,gBAA6FC,GAChGvG,KAAM,CAEJ2G,YAAaD,IC5HnB,IAEME,EAAa,2BACbC,EAAkB,cAEpBC,EAAyC,KAC7C,SAASC,IACP,OAAID,IAIJA,EAAY,IAAIrE,SAAQ,SAACJ,EAASL,GAChC,IACE,IAAMgF,EAAUC,UAAUC,KAbhB,8BACG,GAcbF,EAAQG,UAAY,SAAAC,GAClB/E,EAAS+E,EAAMC,OAA4BnH,SAG7C8G,EAAQM,QAAU,SAAAF,SAChBpF,EACEY,EAAcO,OAAM,eAA6B,CAC/CgC,qBAAwD,QAAjC,EAAAiC,EAAMC,OAAsB9J,aAAK,eAAE6H,YAKhE4B,EAAQO,gBAAkB,SAAAH,GACxB,IAAMI,EAAMJ,EAAMC,OAA4BnH,OAO9C,GACO,IADCkH,EAAMK,WAEVD,EAAGE,kBAAkBd,EAAY,CAC/Be,QAAS,kBAIjB,MAAOvH,GACP4B,EACEY,EAAcO,OAAM,eAA6B,CAC/CgC,qBAAsB/E,EAAEgF,yBASlBwC,EACdzQ,GAEA,OAAO0Q,EAAKC,EAAW3Q,aAUT4Q,EAA2BhC,GACzC,OAAOiC,EAAMnB,EAAiBd,YAGhBkC,IACd,OAAOJ,EAAKhB,YAGCmB,EAAM,EAAN,wEAAf,WAAqBE,EAAa5D,GAAlC,2FACmByC,IADnB,cACQS,EADR,OAGQW,EAAcX,EAAGW,YAAYvB,EAAY,aACzCwB,EAAQD,EAAYE,YAAYzB,GAChCI,EAAUoB,EAAME,IAAI,CACxBC,aAAcL,EACd5D,MAAAA,IAPJ,kBAUS,IAAI7B,SAAQ,SAACJ,EAASL,GAC3BgF,EAAQG,UAAY,SAAAqB,GAClBnG,KAGF8F,EAAYb,QAAU,SAAAF,SACpBpF,EACEY,EAAcO,OAAM,cAA8B,CAChDgC,qBAAwD,QAAjC,EAAAiC,EAAMC,OAAsB9J,aAAK,eAAE6H,gBAlBpE,2EAyBeyC,EAAK,wEAApB,WAAoBK,GAApB,2FACmBnB,IADnB,cACQS,EADR,OAGQW,EAAcX,EAAGW,YAAYvB,EAAY,YACzCwB,EAAQD,EAAYE,YAAYzB,GAChCI,EAAUoB,EAAMtH,IAAIoH,GAL5B,kBAOS,IAAIzF,SAAQ,SAACJ,EAASL,GAC3BgF,EAAQG,UAAY,SAAAC,GAClB,IAAMlH,EAAUkH,EAAMC,OAAsBnH,OAG1CmC,EADEnC,EACMA,EAAOoE,WAEPmE,IAIZN,EAAYb,QAAU,SAAAF,SACpBpF,EACEY,EAAcO,OAAM,cAA4B,CAC9CgC,qBAAwD,QAAjC,EAAAiC,EAAMC,OAAsB9J,aAAK,eAAE6H,gBArBpE,kEA4BA,SAAS0C,EAAW3Q,GAClB,gBAAUA,EAAI2C,QAAQwM,MAAtB,YAA+BnP,EAAIoC,MClI9B,IAAMmP,EAAS,IAAI,KAAO,6DCa1B,WACLvR,GADK,0EAGD,UAHC,wBAIC4O,OAAQ0C,EAJT,kBAMab,EAAuBzQ,GANpC,OAMD4O,EANC,uDASD2C,EAAOC,KAAP,6DATC,iCAWI5C,GAXJ,sCAcE0C,GAdF,yFAoBSG,EACdzR,EACA4O,GAEA,OAAI,mBFyBJ5O,EACA4O,GAEA,OAAOiC,EAAMF,EAAW3Q,GAAM4O,GE3BrB8C,CAAsB1R,EAAK4O,GAAOzI,OAAM,SAAA8C,GAE7CsI,EAAOC,KAAP,qDAA0DvI,OAIvDqC,QAAQJ,gDAGV,2FAKDyG,OAAyCL,EALxC,kBAOwBR,IAPxB,OAOHa,EAPG,gEAYAA,EAZA,wBAoBHf,EANMgB,EAAW1F,KAMoB/F,OAAM,SAAA8C,GAAC,OAC1CsI,EAAOC,KAAP,6DAAkEvI,OArBjE,kBAuBI2I,GAvBJ,iCAyBID,GAzBJ,yFCtCSE,KAEd,OADmB9H,IACDN,iBAGEqI,6EAAf,uFACCjI,EAAQE,KAEJN,UAAWI,EAAM+E,MAHtB,yCAII/E,EAAM+E,MAAMzD,SAJhB,aAOGR,MAAM,qEAPT,2EAaSoH,KACd,IAAMC,GAAU,UACVC,EAAalI,IAKnB,GAFAkI,EAAWzI,aAAc,EAG0B,kBAA1CwI,EAAQE,gCAC2B,IAA1CF,EAAQE,8BAFV,CAOAD,EAAWxI,SAAU,EACrB,IAAM0I,EAAgB,IAAI,KAC1BF,EAAWrD,MAAQuD,EAEkC,kBAA1CH,EAAQE,8BACjBC,EAAcjH,QAAQ8G,EAAQE,+BAE9BC,EAAcjH,kDAAQkH,KC5BnB,IAAMC,GAAwB,CAAEjM,MAAO,0BAqBxBkM,GAAAA,2EAAf,WACLC,GADK,oGAELC,EAFK,gCAKLzG,EADM/L,EAAMuS,EAASvS,KAGf6J,EAAQH,EAAS1J,GAKnB4O,EAA2C/E,EAAM+E,MACjDxI,OAA2BkL,EAK1B1C,EAlBA,iCAoBuB/E,EAAM4I,mBApB7B,QAoBGC,EApBH,SAqBgBC,GAAQD,KACzB9D,EAAQ8D,GAtBP,WA2BAF,IAAgB5D,IAAS+D,GAAQ/D,GA3BjC,0CA4BI,CACLA,MAAOA,EAAMA,QA7BZ,WAoCDgE,GAAsB,GAOtBf,KA3CC,oBA6CEhI,EAAMgJ,qBA7CR,6BA8C4BzF,EA9C5B,KA+CCkC,EA/CD,KA+C8BtP,EA/C9B,UA+CyC8R,KA/CzC,kDAgDCS,EAASlF,uBAFXxD,EAAMgJ,sBA9CL,mBAiDC3M,MAAK,SAAA0I,GAEL,OADA/E,EAAMgJ,0BAAuBvB,EACtB1C,KAETgE,GAAsB,EArDrB,yBAwDK/I,EAAMgJ,qBAxDX,eAuDGC,EAvDH,iBA0DGrB,EAAoBzR,EAAK8S,GA1D5B,eA4DHlJ,EAAS5J,EAAG,+BAAO6J,GAAK,CAAE+E,MAAOkE,KA5D9B,kBA6DI,CAAElE,MAAOkE,EAAuBlE,QA7DpC,yBAqEE/E,EAAMgJ,uBAIThJ,EAAMgJ,qBAAuBhJ,EAAM5J,SAAUqS,WAAWpM,MAAK,SAAA0I,GAE3D,OADA/E,EAAMgJ,0BAAuBvB,EACtB1C,KAETgE,GAAsB,GA7ErB,UA+EW/I,EAAMgJ,qBA/EjB,QA+EHjE,EA/EG,0DAiFE,KAAoBmE,OAApB,mBAAyC,aAE5CxB,EAAOC,KAAM,KAAoBvD,SAGjCsD,EAAOnL,MAAP,MAGFA,EAAQ,EAAH,GAzFF,WA6FAwI,EA7FA,iBAgGHoE,EAAqBC,GAAqB7M,GAhGvC,+BAkGH4M,EAAqB,CACnBpE,MAAOA,EAAMA,OAIfhF,EAAS5J,EAAG,+BAAO6J,GAAK,CAAE+E,MAAAA,KAvGvB,UAwGG6C,EAAoBzR,EAAK4O,GAxG5B,eA2GDgE,GACFM,GAAqBlT,EAAKgT,GA5GvB,kBA8GEA,GA9GF,6FAiHS,GACdT,EACAY,EACAC,EACAC,GAEA,IAAQrT,EAAQuS,EAARvS,IACF6J,EAAQH,EAAS1J,GACjBsT,EAAuC,CAC3CC,KAAMH,EACNhN,MAAOiN,EACPF,KAAAA,GASF,GAPAvJ,EAAS5J,EAAG,+BACP6J,GAAK,CACRP,eAAgB,GAAF,eAAMO,EAAMP,gBAAZ,CAA4BgK,OAKxCzJ,EAAM+E,OAAS+D,GAAQ9I,EAAM+E,OAAQ,CACvC,IAAM4E,EAAa3J,EAAM+E,MACzBtD,QAAQJ,UACLhF,MAAK,WACJkN,EAAS,CAAExE,MAAO4E,EAAW5E,QAC7B6E,GAAmBlB,MAEpBpM,OAAM,eAgBN0D,EAAM4I,mBAAoBvM,MAAK,kBAAMuN,GAAmBlB,eAG/C,GACdvS,EACAoT,GAEA,IAAMvJ,EAAQH,EAAS1J,GAEjB0T,EAAe7J,EAAMP,eAAeqK,QACxC,SAAAL,GAAa,OAAIA,EAAcC,OAASH,KAGhB,IAAxBM,EAAalS,QACbqI,EAAM+J,gBACN/J,EAAM+J,eAAeC,aAErBhK,EAAM+J,eAAe7I,OAGvBnB,EAAS5J,EAAG,+BACP6J,GAAK,CACRP,eAAgBoK,KAOpB,SAASD,GAAmBlB,GAC1B,IAAQvS,EAAQuS,EAARvS,IACF6J,EAAQH,EAAS1J,GAGnB8T,EAAmCjK,EAAM+J,eACxCE,IACHA,EAQJ,SAA8BvB,GAC5B,IAAQvS,EAAQuS,EAARvS,IACR,OAAO,IAAIkK,GAAJ,eAGL,qFACgBR,EAAS1J,GAIZ4O,MALb,gCAMmB0D,GAASC,GAN5B,OAMIxJ,EANJ,8CAQmBuJ,GAASC,GAAU,GARtC,OAQIxJ,EARJ,mBAYMA,EAAO3C,MAZb,uBAaU2C,EAAO3C,MAbjB,6CAgBA,WACE,OAAO,KAET,WACE,IAAMyD,EAAQH,EAAS1J,GAEvB,GAAI6J,EAAM+E,MAAO,CAEf,IAAImF,EACFlK,EAAM+E,MAAMG,mBAEV,IADDlF,EAAM+E,MAAME,iBAAmBjF,EAAM+E,MAAMG,oBAE5C,IAEIiF,EACJnK,EAAM+E,MAAME,iBAAmB,IAKjC,OAJAiF,EAAwBzH,KAAK2H,IAC3BF,EACAC,GAEK1H,KAAK4H,IAAI,EAAGH,EAAwBxN,KAAKoI,OAEhD,OAAO,IAGX1E,EACAA,GAvDYkK,CAAqB5B,GACjC3I,EAAS5J,EAAG,+BAAO6J,GAAK,CAAE+J,eAAgBE,OAEvCA,EAAUD,aAAehK,EAAM1J,2BAClC2T,EAAUM,iBAuDElB,GACdlT,EACA4O,GAEA,IAF0B,EAEpByF,EAAY3K,EAAS1J,GAAKsJ,eAFN,UAIH+K,GAJG,IAI1B,2BAAkC,KAAvBC,EAAuB,QAChC,IACmB,aAAbA,EAASnB,MAAiD,MAAfvE,EAAMxI,MAInDkO,EAASlO,MAAOwI,EAAMxI,OAKtBkO,EAASf,KAAK3E,GAEhB,MAAO3F,MAjBe,wCAuBZ0J,GAAQ/D,GACtB,OAAOA,EAAME,iBAAmBvI,KAAKoI,MAAQ,EAG/C,SAASsE,GAAqB7M,GAC5B,MAAO,CACLwI,OAvSF2F,EAuS0BlC,GArSnB,kBACLzE,KAAKC,UAAU0G,IACA,IAoSfnO,MAAAA,OAxSFmO,MChBWC,GAAA,WACX,WACSxU,EACAqN,IAAmD,eADnD,KAAArN,IAAAA,EACA,KAAAqN,uBAAAA,wCAET,WACE,IADK,EACG/D,EAAmBI,EAASe,KAAKzK,KAAjCsJ,eADH,UAEuBA,GAFvB,IAEL,2BAA4C,KAAjCgK,EAAiC,QAC1C,GAAoB7I,KAAKzK,IAAKsT,EAAcC,OAHzC,8BAKL,OAAOjI,QAAQJ,gBAVN,OCTAuJ,GAAgB,0CAChBC,GACX,0DAEcC,GACd3U,EACA4U,GAEA,IAAM/K,EAAQH,EAAS1J,GACjBwJ,EAAc,IAAI,KAExBI,EAAS5J,EAAG,+BAAO6J,GAAK,CAAEgL,eAAgB,CAAErL,YAAAA,MAC5C,IAAMsL,EAAQC,GAAQ/U,GAEhB6L,EAAaH,GAAa,GAchC,OAbKG,EAWHmJ,GAAkBhV,EAAK4U,EAAS/I,EAAYiJ,EAAOtL,GA+GvD,SAA+ByL,GAC7B,IAAMC,EAASC,SAASC,cAAc,UACtCF,EAAOG,IAAMZ,GACbS,EAAOD,OAASA,EAChBE,SAASG,KAAKC,YAAYL,GA7HxBM,EAAsB,WACpB,IAAM3J,EAAaH,GAAa,GAEhC,IAAKG,EAEH,MAAM,IAAIlB,MAAM,gBAElBqK,GAAkBhV,EAAK4U,EAAS/I,EAAYiJ,EAAOtL,MAKhDA,EAAY2B,iBAELsK,GACdzV,EACA4U,GAEA,IAAM/K,EAAQH,EAAS1J,GACjBwJ,EAAc,IAAI,KAExBI,EAAS5J,EAAG,+BAAO6J,GAAK,CAAEgL,eAAgB,CAAErL,YAAAA,MAC5C,IAAMsL,EAAQC,GAAQ/U,GAEhB6L,EAAaH,GAAa,GAchC,OAbKG,EAWHmJ,GAAkBhV,EAAK4U,EAAS/I,EAAYiJ,EAAOtL,GA4FvD,SAAuCyL,GACrC,IAAMC,EAASC,SAASC,cAAc,UACtCF,EAAOG,IAAMX,GACbQ,EAAOD,OAASA,EAChBE,SAASG,KAAKC,YAAYL,GA1GxBQ,EAA8B,WAC5B,IAAM7J,EAAaH,GAAa,GAEhC,IAAKG,EAEH,MAAM,IAAIlB,MAAM,gBAElBqK,GAAkBhV,EAAK4U,EAAS/I,EAAYiJ,EAAOtL,MAKhDA,EAAY2B,QAOrB,SAAS6J,GACPhV,EACA4U,EACA/I,EACA8J,EACAnM,GAEAqC,EAAW+J,OAAM,YA+CnB,SACE5V,EACA4U,EACA/I,EACA8J,GAEA,IAAME,EAAWhK,EAAWiK,OAAOH,EAAW,CAC5CI,QAASnB,EACToB,KAAM,cAGFnM,EAAQH,EAAS1J,GAEvB4J,EAAS5J,EAAG,+BACP6J,GAAK,CACRgL,eAAgB,OAAF,wBACThL,EAAMgL,gBAAe,CACxBgB,SAAAA,OA7DFI,CAAsBjW,EAAK4U,EAAS/I,EAAY8J,GAChDnM,EAAY0B,QAAQW,MAOxB,SAASkJ,GAAQ/U,GACf,IAAM8U,EAAQ,kBAAH,OAAqB9U,EAAIoC,MAC9B8T,EAAef,SAASC,cAAc,OAK5C,OAJAc,EAAavV,GAAKmU,EAClBoB,EAAaC,MAAMC,QAAU,OAE7BjB,SAAStM,KAAK0M,YAAYW,GACnBpB,WAGaxC,GAAAA,2EAAf,WAAwBtS,GAAxB,8EACL+L,EAAgB/L,GAGV6U,EAAiBnL,EAAS1J,GAAK6U,eAJhC,SAKmBA,EAAerL,YAAY2B,QAL9C,cAKCkL,EALD,yBAOE,IAAI/K,SAAQ,SAACJ,EAASoL,GAE3B,IAAMzB,EAAiBnL,EAAS1J,GAAK6U,eACrCwB,EAAUT,OAAM,WACd1K,EAEEmL,EAAUE,QAAQ1B,EAAegB,SAAW,CAC1CW,OAAQ,2BAdX,sECjEMtW,GAAA,WAYX,WAAoBuW,IAAgB,eAAhB,KAAAA,SAAAA,EALZ,KAAAC,cAAqC,6EAW7C,6FACEC,GAAiBlM,KAAKiM,eADxB,SAKoCE,GAAkBnM,KAAKoM,MAAO1Q,OAC9D,SAAA2Q,GAEE,MAAMrL,EAAcO,OAAM,sBARhC,cAKQ+K,EALR,yBAamB3J,EACb4B,EAAmCvE,KAAKoM,KAAOE,GAC/CtM,KAAKuM,yBAfX,OAaIjO,EAbJ,4DAkBiC,uBAAxB,KAAoBgK,KAlB7B,uBAmBMtI,KAAKiM,cAAgBO,GACnBxI,OAAsC,QAA9B,OAAoByI,kBAAU,eAAE/I,YACxC1D,KAAKiM,eAEDjL,EAAcO,OAAM,YAA0B,CAClDmL,KAAM1K,EACJhC,KAAKiM,cAAcU,mBAAqB7Q,KAAKoI,OAE/CR,WAAY1D,KAAKiM,cAAcvI,aA3BvC,kCAkCE1D,KAAKiM,cAAgB,KAlCvB,kBAmCS3N,GAnCT,wIAyCA,SAAW/I,GACTyK,KAAKoM,KAAO7W,EACZyK,KAAKuM,yBAA0B,QAAahX,EAAK,mBACjDqX,GAAsBrX,EAAKyK,KAAKgM,UAAUtQ,OAAM,sCAQlD,SAAQmR,GACN,OAAIA,aAAyBpX,GACpBuK,KAAKgM,WAAaa,EAAcb,eAxEhC,GAqFAc,GAAA,WAYX,WAAoBd,IAAgB,eAAhB,KAAAA,SAAAA,EALZ,KAAAC,cAAqC,6EAW7C,6FACEC,GAAiBlM,KAAKiM,eADxB,SAIoCE,GAAkBnM,KAAKoM,MAAO1Q,OAC9D,SAAA2Q,GAEE,MAAMrL,EAAcO,OAAM,sBAPhC,cAIQ+K,EAJR,yBAYmB3J,EACbiC,EACE5E,KAAKoM,KACLE,GAEFtM,KAAKuM,yBAjBX,OAYIjO,EAZJ,4DAoBiC,uBAAxB,KAAoBgK,KApB7B,uBAqBMtI,KAAKiM,cAAgBO,GACnBxI,OAAsC,QAA9B,OAAoByI,kBAAU,eAAE/I,YACxC1D,KAAKiM,eAEDjL,EAAcO,OAAM,YAA0B,CAClDmL,KAAM1K,EACJhC,KAAKiM,cAAcU,mBAAqB7Q,KAAKoI,OAE/CR,WAAY1D,KAAKiM,cAAcvI,aA7BvC,kCAoCE1D,KAAKiM,cAAgB,KApCvB,kBAqCS3N,GArCT,wIA2CA,SAAW/I,GACTyK,KAAKoM,KAAO7W,EACZyK,KAAKuM,yBAA0B,QAAahX,EAAK,mBACjDwX,GAA8BxX,EAAKyK,KAAKgM,UAAUtQ,OAAM,sCAQ1D,SAAQmR,GACN,OAAIA,aAAyBC,GACpB9M,KAAKgM,WAAaa,EAAcb,eA1EhC,GAqFAgB,GAAA,WAGX,WAAoBC,IAA6C,eAA7C,KAAAA,uBAAAA,0EAKpB,sGAE4BjN,KAAKiN,uBAAuBpF,WAFxD,cAEQqF,EAFR,OAKQC,GAAsB,QAAaD,EAAY/I,OAG/CG,EACoB,OAAxB6I,GACAA,EAAsBrR,KAAKoI,OAC3BiJ,EAAsB,EACI,IAAtBA,EACArR,KAAKoI,MAbb,kBAeE,+BAAYgJ,GAAW,CAAE5I,mBAAAA,KAf3B,8HAqBA,SAAW/O,GACTyK,KAAKoM,KAAO7W,yBAMd,SAAQsX,GACN,OAAIA,aAAyBG,GAEzBhN,KAAKiN,uBAAuBpF,SAAS9F,aACrC8K,EAAcI,uBAAuBpF,SAAS9F,iBAxCzC,GAwDb,SAASyK,GACP9I,EACA0J,GAYA,GAAmB,MAAf1J,GAAqC,MAAfA,EACxB,MAAO,CACL2J,aAAc,EACdV,mBAAoB7Q,KAAKoI,MZrPR,MYsPjBR,WAAAA,GAOF,IAAM2J,EAAeD,EAAeA,EAAaC,aAAe,EAC1DC,GAAgB,QAAuBD,EAAc,IAAM,GACjE,MAAO,CACLA,aAAcA,EAAe,EAC7BV,mBAAoB7Q,KAAKoI,MAAQoJ,EACjC5J,WAAAA,GAKN,SAASwI,GAAiBkB,GACxB,GAAIA,GACEtR,KAAKoI,MAAQkJ,EAAaT,oBAAsB,EAElD,MAAM3L,EAAcO,OAAM,YAA0B,CAClDmL,KAAM1K,EAAkBoL,EAAaT,mBAAqB7Q,KAAKoI,OAC/DR,WAAY0J,EAAa1J,sBC/PjBpO,KAEU,IADxBC,EACwB,wDADL,UACnB2C,EAAwB,uCAExB3C,GAAM,QAAmBA,GACzB,IAAMC,GAAW,QAAaD,EAAK,aAmBnC,GAhBK+J,IAAgBP,aACnBuI,KAKEF,MAEGC,KAAgB5L,MAAK,SAAA0I,GAAK,OAE7BzG,QAAQzH,IAAR,iCAC4BkO,EAD5B,0GAMA3O,EAAS+X,gBAAiB,CAC5B,IAAMC,EAAmBhY,EAASuN,eAC5B0K,EAAiBjY,EAASkY,aAChC,GACED,EAAe/X,4BACbwC,EAAQxC,2BACV+X,EAAejY,SAASmY,QAAQzV,EAAQ1C,UAExC,OAAOgY,EAEP,MAAMxM,EAAcO,OAAM,sBAAoC,CAC5DC,QAASjM,EAAIoC,OAKnB,IAAMmQ,EAAWtS,EAASoY,WAAW,CAAE1V,QAAAA,IAcvC,OAbA2V,GAAUtY,EAAK2C,EAAQ1C,SAAU0C,EAAQxC,2BAIrCuJ,EAAS1J,GAAKG,2BAMhB,GAAiBoS,EAAQ,YAAyB,eAG7CA,EAaT,SAAS+F,GACPtY,EACAC,EACAE,GAEA,IAAM0J,EAAQH,EAAS1J,GAEjBuY,EAAQ,+BAAuB1O,GAAK,CAAER,WAAW,IACvDkP,EAAStY,SAAWA,EACpBsY,EAAS9F,4BNtGgC,kCMsGX+F,CAAqBxY,GAAKkG,MAAK,SAAAwM,GAM3D,OALIA,GAAeC,GAAQD,KACzB9I,EAAS5J,EAAG,+BAAO0J,EAAS1J,IAAI,CAAE4O,MAAO8D,KAEzCQ,GAAqBlT,EAAK,CAAE4O,MAAO8D,EAAY9D,SAE1C8D,KAMT6F,EAASpY,+BACuBmR,IAA9BnR,EACIH,EAAIyY,+BACJtY,EAENyJ,EAAS5J,EAAKuY,GAEdA,EAAStY,SAASoY,WAAWrY,YAYf0Y,GACdC,EACAxY,GAEA,IAAMH,EAAM2Y,EAAiB3Y,IACvB6J,EAAQH,EAAS1J,GAGnB6J,EAAM+J,kBAC0B,IAA9BzT,EACF0J,EAAM+J,eAAeQ,QAErBvK,EAAM+J,eAAe7I,QAGzBnB,EAAS5J,EAAG,+BAAO6J,GAAK,CAAE1J,0BAAAA,cAYNmS,GAAS,EAAT,2EAAf,WACLqG,EACAnG,GAFK,qFAIgBoG,GACnBD,EACAnG,GANG,YAICzJ,EAJD,QAQM3C,MARN,sBASG2C,EAAO3C,MATV,gCAWE,CAAEwI,MAAO7F,EAAO6F,QAXlB,2EA4DSiK,GACdF,EACAG,EAGAzF,EAQA0F,GAEA,IAAIC,EAAsC,aACtCC,EAAmB,aAuBvB,OArBED,EADqE,MAAlEF,EAA0DvF,KAE3DuF,EACAvF,KAAM2F,KAAKJ,GAEJA,EAG2D,MAAnEA,EAA0D1S,MAE3D6S,EACEH,EACA1S,MAAO8S,KAAKJ,GACLzF,IACT4F,EAAU5F,GAEZ,GACEsF,EAAmC,WAEnCK,EACAC,GAEK,kBAAM,GAAoBN,EAAiB3Y,IAAKgZ,IC5PzD,IACMG,GACJ,sBAGA,QACE,IAAI,KANuC,aAQzC,SAAAxD,GAIE,gBJLN3V,EACAqN,GAEA,OAAO,IAAImH,GAAgBxU,EAAKqN,GIEnB+L,CAFKzD,EAAU0D,YAAY,OAAO7L,eACVmI,EAAU0D,YAAY,sBAEtD,UAGAC,qBAAoB,YAKpBC,4BACC,SAAC5D,EAAW6D,EAAaC,GACvB9D,EAAU0D,YAAYF,IAAyBd,kBAMvD,QACE,IAAI,KACFc,IACA,SAAAxD,GAEE,gBJpBNpD,GAEA,MAAO,CACLD,SAAU,SAAAE,GAAY,OAAIF,GAASC,EAAUC,IAC7CkH,iBAAkB,SAAAtG,GAAQ,OACxB,GAAiBb,EAAQ,WAAyBa,IACpDuG,oBAAqB,SAAAvG,GAAQ,OAAI,GAAoBb,EAASvS,IAAKoT,KIcxDwG,CADUjE,EAAU0D,YAAY,aAAa7L,kBAErD,UAED8L,qBAAoB,cAGxB,mFCnCcO,EAAIzT,GAAAA,IAAAA,IAAAA,EAAAA,UAAAA,OAA+B0T,EAAAA,MAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAAA,UAAAA,GAQtBC,MAElBpP,MAAAA,8BACqBvE,GAC7B0T,EAAKtY,OAAS,IAAMsY,EAAKE,KAAI,sBAASC,EAAAA,OAAMC,KAAK,KAAO,iECvC3CC,EAAQhN,GAAAA,QACdA,KAAWA,EAAMiN,GAAAA,SAKXC,EAAYlN,GAAAA,QACtBA,IAAAA,SAawBA,GAAAA,IACxBA,GAA0B,iBAAVA,EAAoB,OAAO,MAC1CmN,EAAQC,OAAOC,eAAerN,GAAAA,GACtB,OAAVmN,EAAAA,OAAAA,EACI,IAEFG,EACLF,OAAOG,eAAeC,KAAKL,EAAO,gBAAkBA,EAAMM,YAAAA,OAEvDH,IAASF,QAGG,mBAARE,GACPI,SAASrO,SAASmO,KAAKF,KAAUK,EA1B7B3N,CAEUA,IACd4N,MAAMC,QAAQ7N,MACZA,EAAM8N,MACN9N,EAAMyN,YAAYK,IACpBC,EAAM/N,IACNgO,EAAMhO,IA0DR,SAAgBiO,EAAKC,EAAUC,EAAWC,QAAAA,IAAAA,IAAAA,GAAAA,GAAiB,IACtDC,EAAYH,IACbE,EAAiBhB,OAAOkB,KAAOC,GAASL,GAAKtW,SAAQ,YACjDwW,GAAiC,iBAARxK,GAAkBuK,EAAKvK,EAAKsK,EAAItK,GAAMsK,MAGrEA,EAAItW,SAAQ,SAAC4W,EAAYpW,GAAAA,OAAe+V,EAAK/V,EAAOoW,EAAON,MAAAA,SAK7CG,EAAYI,GAAAA,IAErB/R,EAAgC+R,EAAMxB,GAAAA,OACrCvQ,EACJA,EAAMgS,EAAQ,EACbhS,EAAMgS,EAAQ,EACbhS,EAAMgS,EACRd,MAAMC,QAAQY,GAAAA,EAEdV,EAAMU,GAAAA,EAENT,EAAMS,GAAAA,EAAAA,EAAAA,SAMME,EAAIF,EAAYG,GAAAA,OAAAA,IACxBP,EAAYI,GAChBA,EAAME,IAAIC,GACVxB,OAAOyB,UAAUtB,eAAeC,KAAKiB,EAAOG,GAAAA,SAIhCpS,EAAIiS,EAA2BG,GAAAA,OAAAA,IAEvCP,EAAYI,GAA0BA,EAAMjS,IAAIoS,GAAQH,EAAMG,GAItE,SAAgBjS,EAAI8R,EAAYK,EAA6B9O,GAAAA,IACtD+O,EAAIV,EAAYI,GAAAA,IAClBM,EAAoBN,EAAM9R,IAAImS,EAAgB9O,GAAAA,IACzC+O,GACRN,EAAMO,OAAOF,GACbL,EAAMQ,IAAIjP,IACJyO,EAAMK,GAAkB9O,EAAAA,SAIhBkP,EAAGC,EAAQC,GAAAA,OAEtBD,IAAMC,EACI,IAAND,GAAW,EAAIA,GAAM,EAAIC,EAEzBD,GAAMA,GAAKC,GAAMA,EAAAA,SAKVrB,EAAMhL,GAAAA,OACdsM,GAAUtM,aAAkB/G,IAAAA,SAIpBgS,EAAMjL,GAAAA,OACduM,GAAUvM,aAAkBwM,IAAAA,SAGpBC,EAAO9S,GAAAA,OACfA,EAAM+S,GAAS/S,EAAMgT,EAAAA,SAIbC,EAAYC,GAAAA,GACvBhC,MAAMC,QAAQ+B,GAAO,OAAOhC,MAAMiB,UAAUgB,MAAMrC,KAAKoC,GAAAA,IACrDE,EAAcC,EAA0BH,UACvCE,EAAY7C,GAAAA,IAAAA,IACfqB,EAAOC,EAAQuB,GACV7X,EAAI,EAAGA,EAAIqW,EAAKja,OAAQ4D,IAAK,KAC/B2L,EAAW0K,EAAKrW,GAChB+X,EAAOF,EAAYlM,IAAAA,IACrBoM,EAAKC,WACRD,EAAKC,UAAAA,EACLD,EAAKE,cAAAA,IAKFF,EAAKxT,KAAOwT,EAAKrT,OACpBmT,EAAYlM,GAAO,CAClBsM,cAAAA,EACAD,UAAAA,EACAE,WAAYH,EAAKG,WACjBnQ,MAAO4P,EAAKhM,KAAAA,OAGRwJ,OAAOvO,OAAOuO,OAAOC,eAAeuC,GAAOE,GAAAA,SAWnCM,EAAUlC,EAAUmC,GAAAA,YAAAA,IAAAA,IAAAA,GAAAA,GAC/BC,EAASpC,IAAQlB,EAAQkB,KAAShB,EAAYgB,KAC9CG,EAAYH,GAAO,IACtBA,EAAIvR,IAAMuR,EAAIe,IAAMf,EAAIqC,MAAQrC,EAAIc,OAASwB,GAE9CpD,OAAOgD,OAAOlC,GACVmC,GAAMpC,EAAKC,GAAK,SAACtK,EAAK5D,GAAAA,OAAUoQ,EAAOpQ,GAAAA,MAAO,IALakO,EAShE,SAASsC,IACR9D,EAAI,YAGW4D,EAASpC,GAAAA,OACb,MAAPA,GAA8B,iBAARA,GAEnBd,OAAOkD,SAASpC,GAAAA,SCzKRuC,EACfC,GAAAA,IAEMC,EAASC,EAAQF,GAAAA,OAClBC,GACJjE,EAAI,GAAIgE,GAGFC,EC3BR,SAAgBE,IAAAA,OAERC,EAAAA,SAkBQC,EACfC,EACAC,GAEIA,IACHR,EAAU,WACVO,EAAME,EAAW,GACjBF,EAAMG,EAAkB,GACxBH,EAAMI,EAAiBH,GAAAA,SAITI,EAAYL,GAC3BM,EAAWN,GACXA,EAAMO,EAAQ3Z,QAAQ4Z,GAEtBR,EAAMO,EAAU,cAGDD,EAAWN,GACtBA,IAAUF,IACbA,EAAeE,EAAMS,GAAAA,SAIPC,EAAWC,GAAAA,OAClBb,EArCD,CACNS,EAAS,GACTE,EAmCkCX,EAlClCc,EAkCgDD,EA/BhDE,GAAAA,EACAC,EAAoB,GAiCtB,SAASN,EAAYxZ,GAAAA,IACd0E,EAAoB1E,EAAMiV,GAAAA,IAE/BvQ,EAAMgS,GAAAA,IACNhS,EAAMgS,EAENhS,EAAMqV,IACFrV,EAAMsV,GAAAA,EAAW,SC9DPC,EAAcrW,EAAaoV,GAC1CA,EAAMc,EAAqBd,EAAMO,EAAQld,OAAAA,IACnC6d,EAAYlB,EAAMO,EAAS,GAC3BY,OAAAA,IAAavW,GAAwBA,IAAWsW,EAAAA,OACjDlB,EAAMY,EAAOQ,GACjB3B,EAAU,OAAO4B,EAAiBrB,EAAOpV,EAAQuW,GAC9CA,GACCD,EAAUjF,GAAaqF,IAC1BjB,EAAYL,GACZtE,EAAI,IAEDQ,EAAYtR,KAEfA,EAAS2W,EAASvB,EAAOpV,GACpBoV,EAAMS,GAASe,EAAYxB,EAAOpV,IAEpCoV,EAAME,GACTT,EAAU,WAAWgC,EACpBP,EAAUjF,GACVrR,EACAoV,EAAME,EACNF,EAAMG,IAKRvV,EAAS2W,EAASvB,EAAOkB,EAAW,IAErCb,EAAYL,GACRA,EAAME,GACTF,EAAMI,EAAgBJ,EAAME,EAAUF,EAAMG,GAEtCvV,IAAW8W,EAAU9W,OAAAA,EAG7B,SAAS2W,EAASI,EAAuB3S,EAAYlM,GAAAA,GAEhDwc,EAAStQ,GAAQ,OAAOA,EAAAA,IAEtBtD,EAAoBsD,EAAMiN,GAAAA,IAE3BvQ,EAAAA,OACJuR,EACCjO,GACA,SAAC4D,EAAKgP,GAAAA,OACLC,EAAiBF,EAAWjW,EAAOsD,EAAO4D,EAAKgP,EAAY9e,MAAAA,GAGtDkM,EAAAA,GAGJtD,EAAMoW,IAAWH,EAAW,OAAO3S,EAAAA,IAElCtD,EAAM4V,EAAAA,OACVE,EAAYG,EAAWjW,EAAMgT,GAAAA,GACtBhT,EAAMgT,EAAAA,IAGThT,EAAMqW,EAAY,CACtBrW,EAAMqW,GAAAA,EACNrW,EAAMoW,EAAOhB,IAAAA,IACPlW,EAAAA,IAELc,EAAMgS,GAAAA,IAAiChS,EAAMgS,EACzChS,EAAM+S,EAAQE,EAAYjT,EAAMsW,GACjCtW,EAAM+S,EAKVxB,EAAAA,IACCvR,EAAMgS,EAA0B,IAAIa,IAAI3T,GAAUA,GAClD,SAACgI,EAAKgP,GAAAA,OACLC,EAAiBF,EAAWjW,EAAOd,EAAQgI,EAAKgP,EAAY9e,MAG9D0e,EAAYG,EAAW/W,GAAAA,GAEnB9H,GAAQ6e,EAAUzB,GACrBT,EAAU,WAAWwC,EACpBvW,EACA5I,EACA6e,EAAUzB,EACVyB,EAAUxB,GAAAA,OAINzU,EAAM+S,EAGd,SAASoD,EACRF,EACAO,EACAC,EACAvE,EACAgE,EACAQ,GAAAA,GAGIpG,EAAQ4F,GAAa,KASlBS,EAAMd,EAASI,EAAWC,EAP/BQ,GACAF,GAAAA,IACAA,EAAaxE,IACZC,EAAKuE,EAA8CI,EAAY1E,GAC7DwE,EAAUG,OAAO3E,QAAAA,GACjBzK,GAGJxH,EAAIwW,EAAcvE,EAAMyE,IAGpBrG,EAAQqG,GAEL,OADNV,EAAUd,GAAAA,EAAiB,GAIzB3E,EAAY0F,KAAgBtC,EAASsC,GAAa,KAChDD,EAAUf,EAAO4B,GAAeb,EAAUb,EAAqB,SAQpES,EAASI,EAAWC,GAEfM,GAAgBA,EAAYJ,EAAOrB,GACvCe,EAAYG,EAAWC,IAI1B,SAASJ,EAAYxB,EAAmBhR,EAAYqQ,QAAAA,IAAAA,IAAAA,GAAAA,GAC/CW,EAAMY,EAAO4B,GAAexC,EAAMa,GACrCzB,EAAOpQ,EAAOqQ,GC6EhB,SAASoD,EAAKzb,EAAgB4W,GAAAA,IACvBlS,EAAQ1E,EAAMiV,GAAAA,OACLvQ,EAAQ8S,EAAO9S,GAAS1E,GACzB4W,GAcf,SAAS8E,EACRC,EACA/E,GAAAA,GAGMA,KAAQ+E,EAAAA,IAAAA,IACVxG,EAAQC,OAAOC,eAAesG,GAC3BxG,GAAO,KACP6C,EAAO5C,OAAOwG,yBAAyBzG,EAAOyB,GAAAA,GAChDoB,EAAM,OAAOA,EACjB7C,EAAQC,OAAOC,eAAeF,IAAAA,SAKhB0G,EAAYnX,GACtBA,EAAM4V,IACV5V,EAAM4V,GAAAA,EACF5V,EAAM+U,GACToC,EAAYnX,EAAM+U,IAAAA,SAKLqC,EAAYpX,GACtBA,EAAM+S,IACV/S,EAAM+S,EAAQE,EAAYjT,EAAMgT,IC5DlC,SAAgBqE,EACfpC,EACA3R,EACAjJ,GAAAA,IAGMiB,EAAiB+V,EAAM/N,GAC1ByQ,EAAU,UAAUuD,EAAUhU,EAAOjJ,GACrCiX,EAAMhO,GACNyQ,EAAU,UAAUwD,EAAUjU,EAAOjJ,GACrC4a,EAAMS,EAAAA,SDhLTxC,EACA7Y,GAAAA,IAEM8W,EAAUD,MAAMC,QAAQ+B,GACxBlT,EAAoB,CACzBgS,EAAOb,EAAAA,EAAkC,EAEzCiF,EAAQ/b,EAASA,EAAO+b,EAASjC,IAEjCyB,GAAAA,EAEAS,GAAAA,EAEAO,EAAW,GAEX7B,EAAS1a,EAET2Y,EAAOE,EAEPoD,EAAQ,KAERvD,EAAO,KAEPsC,EAAS,KACTmC,GAAAA,GASGnR,EAAYrG,EACZyX,EAA2CC,EAC3CvG,IACH9K,EAAS,CAACrG,GACVyX,EAAQE,GAAAA,IAAAA,EAGeC,MAAMC,UAAUxR,EAAQoR,GAAzCK,EAAAA,EAAAA,OAAQC,EAAAA,EAAAA,MAAAA,OACf/X,EAAMsW,EAASyB,EACf/X,EAAMqV,EAAUyC,EACTC,ECqIErC,CACWpS,EAAOjJ,GACxB0Z,EAAU,OAAOiE,EAAgB1U,EAAOjJ,GAAAA,OAE7BA,EAASA,EAAO+b,EAASjC,KACjCU,EAAQzZ,KAAKE,GACZA,EAAAA,SCvNQ2c,EAAQ3U,GAAAA,OAClBgN,EAAQhN,IAAQ0M,EAAI,GAAI1M,GAI9B,SAAS4U,EAAY5U,GAAAA,IACfkN,EAAYlN,GAAQ,OAAOA,EAAAA,IAE5B6U,EADEnY,EAAgCsD,EAAMiN,GAEtC6H,EAAWzG,EAAYrO,GAAAA,GACzBtD,EAAO,KAERA,EAAM4V,IACN5V,EAAMgS,EAAQ,IAAM+B,EAAU,OAAOsE,EAAYrY,IAElD,OAAOA,EAAMgT,EAEdhT,EAAMqW,GAAAA,EACN8B,EAAOG,EAAWhV,EAAO8U,GACzBpY,EAAMqW,GAAAA,OAEN8B,EAAOG,EAAWhV,EAAO8U,GAAAA,OAG1B7G,EAAK4G,GAAM,SAACjR,EAAKgP,GACZlW,GAASF,EAAIE,EAAMgT,EAAO9L,KAASgP,GACvCjW,EAAIkY,EAAMjR,EAAKgR,EAAYhC,OAAAA,IAGrBkC,EAA4B,IAAIvF,IAAIsF,GAAQA,EAxBpD,CAHoB7U,GA8BpB,SAASgV,EAAWhV,EAAY8U,GAAAA,OAEvBA,GAAAA,KAAAA,EAAAA,OAEC,IAAI9Y,IAAIgE,GAAAA,KAAAA,EAAAA,OAGR4N,MAAMqH,KAAKjV,GAAAA,OAEb2P,EAAY3P,wFCkDZA,IAAAA,ELnFJ8Q,EMpBEoE,EACa,oBAAX5iB,QAAiD,iBAAhBA,OAAO,KACnC+c,EAAwB,oBAARrT,IAChBsT,EAAwB,oBAARC,IAChB4F,EACK,oBAAVb,YAAAA,IACAA,MAAMC,WACM,oBAAZa,QAKK1C,EAAmBwC,EAC7B5iB,OAAO+iB,IAAI,yBACR,oBAAkB,GAUXvH,EAA2BoH,EACrC5iB,OAAO+iB,IAAI,mBACV,qBAESpI,EAA6BiI,EACvC5iB,OAAO+iB,IAAI,eACV,iBRAE1H,GQIa,oBAAVrb,QAAyBA,OAAOC,SRJhB6a,GAAAA,OAAOyB,UAAUpB,aA4B7Bc,EACO,oBAAZ6G,SAA2BA,QAAQ7G,QACvC6G,QAAQ7G,aAAAA,IACDnB,OAAOkI,sBACd,mBACAlI,OAAOmI,oBAAoBrH,GAAKqF,OAC/BnG,OAAOkI,sBAAsBpH,KAEHd,OAAOmI,oBAEzBxF,EACZ3C,OAAO2C,2BACP,SAAmChN,GAAAA,IAE5BsQ,EAAW,UACjB9E,EAAQxL,GAAQnL,SAAQ,YACvByb,EAAIzP,GAAOwJ,OAAOwG,yBAAyB7Q,EAAQa,MAE7CyP,GCnEHzC,EA4BF,GGyDSwD,EAAwC,CACpD5X,IAAAA,SAAIE,EAAOkS,GAAAA,GACNA,IAAS3B,EAAa,OAAOvQ,EAAAA,IAE3BiX,EAASnE,EAAO9S,GAAAA,IACjBiS,EAAIgF,EAAQ/E,GAAAA,OAuInB,SAA2BlS,EAAmBiX,EAAa/E,GAAAA,IAAAA,EACpDoB,EAAO0D,EAAuBC,EAAQ/E,GAAAA,OACrCoB,EACJ,UAAWA,EACVA,EAAKhQ,MAAAA,QAAAA,EAGLgQ,EAAKxT,WAAAA,IAAAA,OAAAA,EAALwT,EAAUxC,KAAK9Q,EAAMsW,QAAAA,EAP1B,CArI4BtW,EAAOiX,EAAQ/E,GAAAA,IAEnC5O,EAAQ2T,EAAO/E,GAAAA,OACjBlS,EAAMqW,IAAe7F,EAAYlN,GAC7BA,EAIJA,IAAUyT,EAAK/W,EAAMgT,EAAOd,IAC/BkF,EAAYpX,GACJA,EAAM+S,EAAOb,GAAemF,EACnCrX,EAAMoW,EAAOlB,EACb5R,EACAtD,IAGKsD,GAER2O,IAAAA,SAAIjS,EAAOkS,GAAAA,OACHA,KAAQY,EAAO9S,IAEvB6R,QAAAA,SAAQ7R,GAAAA,OACA0Y,QAAQ7G,QAAQiB,EAAO9S,KAE/BC,IAAAA,SACCD,EACAkS,EACA5O,GAAAA,IAEMgQ,EAAO0D,EAAuBlE,EAAO9S,GAAQkS,GAAAA,GAC/CoB,MAAAA,OAAAA,EAAAA,EAAMrT,IAAAA,OAGTqT,EAAKrT,IAAI6Q,KAAK9Q,EAAMsW,EAAQhT,IAAAA,EACrB,IAEHtD,EAAM4V,EAAW,KAGfqC,EAAUlB,EAAKjE,EAAO9S,GAAQkS,GAE9B4G,EAAiCb,MAAAA,OAAAA,EAAAA,EAAU1H,GAAAA,GAC7CuI,GAAgBA,EAAa9F,IAAU1P,EAAAA,OAC1CtD,EAAM+S,EAAOb,GAAQ5O,EACrBtD,EAAM4W,EAAU1E,IAAAA,GAAQ,EACjB,GAEJM,EAAGlP,EAAO2U,UAAAA,IAAa3U,GAAuB2O,EAAIjS,EAAMgT,EAAOd,IAClE,OAAO,EACRkF,EAAYpX,GACZmX,EAAYnX,GAAAA,OAIZA,EAAM+S,EAAOb,KAAU5O,GAEN,iBAAVA,SAAAA,IAENA,GAAuB4O,KAAQlS,EAAM+S,KAKvC/S,EAAM+S,EAAOb,GAAQ5O,EACrBtD,EAAM4W,EAAU1E,IAAAA,GAAQ,IAGzB6G,eAAAA,SAAe/Y,EAAOkS,GAAAA,YAAAA,IAEjB6E,EAAK/W,EAAMgT,EAAOd,IAAuBA,KAAQlS,EAAMgT,GAC1DhT,EAAM4W,EAAU1E,IAAAA,EAChBkF,EAAYpX,GACZmX,EAAYnX,WAGLA,EAAM4W,EAAU1E,GAGpBlS,EAAM+S,UAAc/S,EAAM+S,EAAMb,IAAAA,GAKrCgF,yBAAAA,SAAyBlX,EAAOkS,GAAAA,IACzB8G,EAAQlG,EAAO9S,GACfsT,EAAOoF,QAAQxB,yBAAyB8B,EAAO9G,GAAAA,OAChDoB,EACE,CACNC,UAAAA,EACAC,aAAAA,IAAcxT,EAAMgS,GAA2C,WAATE,EACtDuB,WAAYH,EAAKG,WACjBnQ,MAAO0V,EAAM9G,IALIoB,GAQnB2F,eAAAA,WACCjJ,EAAI,KAELW,eAAAA,SAAe3Q,GAAAA,OACP0Q,OAAOC,eAAe3Q,EAAMgT,IAEpCkG,eAAAA,WACClJ,EAAI,MAQA2H,EAA8C,GACpDpG,EAAKmG,GAAa,SAACxQ,EAAKiS,GAEvBxB,EAAWzQ,GAAO,kBACjBkS,UAAU,GAAKA,UAAU,GAAG,GACrBD,EAAGE,MAAMzY,KAAMwY,eAGxBzB,EAAWoB,eAAiB,SAAS/Y,EAAOkS,GAAAA,OAEpCwF,EAAYqB,eAAgBjI,KAAKlQ,KAAMZ,EAAM,GAAIkS,IAEzDyF,EAAW1X,IAAM,SAASD,EAAOkS,EAAM5O,GAAAA,OAE/BoU,EAAYzX,IAAK6Q,KAAKlQ,KAAMZ,EAAM,GAAIkS,EAAM5O,EAAOtD,EAAM,SCnMpDsZ,EAAb,oBAAAla,EAKarJ,GAAAA,IAAAA,EAAAA,KAAAA,KAAAA,EAJW0iB,EAAAA,KAAAA,GAAAA,EAEA,aA4BH,SAACvF,EAAWqG,EAAchF,GAAAA,GAEzB,mBAATrB,GAAyC,mBAAXqG,EAAuB,KACzDC,EAAcD,EACpBA,EAASrG,EAAAA,IAEHnR,EAAO0X,EAAAA,OACN,SAENvG,GAAAA,IAAAA,EAAAA,UAAAA,IAAAA,IAAAA,EAAOsG,GAAAA,IAAAA,IAAAA,EAAAA,UAAAA,OACJvJ,EAAAA,MAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAAA,UAAAA,GAAAA,OAEIlO,EAAK2X,QAAQxG,GAAM,SAAC5X,GAAAA,IAAAA,EAAAA,OAAAA,EAAmBie,GAAOzI,KAAAA,MAAAA,EAAAA,CAAK6I,EAAMre,GAAAA,OAAU2U,QAAAA,IAQxE/Q,EAAAA,GAJkB,mBAAXqa,GAAuBvJ,EAAI,YAClCuE,GAAwD,mBAAlBA,GACzCvE,EAAI,GAKDQ,EAAY0C,GAAO,KAChBoB,EAAQU,EAAWyE,GACnB1B,EAAQV,EAAYoC,EAAMvG,OAAAA,GAC5B0G,GAAAA,EAAW,IAEd1a,EAASqa,EAAOxB,GAChB6B,GAAAA,EAHc,QAMVA,EAAUjF,EAAYL,GACrBM,EAAWN,GAAAA,MAEM,oBAAZ7S,SAA2BvC,aAAkBuC,QAChDvC,EAAO7C,MACb,mBACCgY,EAAkBC,EAAOC,GAClBgB,EAAcrW,EAAQoV,MAE9B,kBACCK,EAAYL,GACN/X,MAIT8X,EAAkBC,EAAOC,GAClBgB,EAAcrW,EAAQoV,IACvB,IAAKpB,GAAwB,iBAATA,EAAmB,KAC7ChU,EAASqa,EAAOrG,MACD8C,EAAS,uBACpB9W,IAAsBA,EAASgU,GAC/BuG,EAAK3C,GAAapD,EAAOxU,GAAAA,GACtBA,EACD8Q,EAAI,GAAIkD,IAAAA,KAAAA,mBAG0B,SACzC2G,EACAC,GAAAA,MAGoB,mBAATD,EACH,SAAC7Z,GAAAA,IAAAA,IAAAA,EAAAA,UAAAA,OAAeiQ,EAAAA,MAAAA,EAAAA,EAAAA,EAAAA,EAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAAA,UAAAA,GAAAA,OACtBwJ,EAAKM,mBAAmB/Z,GAAO,SAAC1E,GAAAA,OAAeue,EAAAA,WAAAA,EAAAA,CAAKve,GAAAA,OAAU2U,QAQzD,CAJWwJ,EAAKC,QAAQG,EAAMC,GAAM,SAACE,EAAYC,GACvDC,EAAUF,EACVG,EAAiBF,KAECC,EAAUC,GAAAA,IALzBD,EAAkBC,GA7FY,kBAAvBpkB,MAAAA,OAAAA,EAAAA,EAAQqkB,aAClBxZ,KAAKyZ,cAActkB,EAAQqkB,YACM,kBAAvBrkB,MAAAA,OAAAA,EAAAA,EAAQukB,aAClB1Z,KAAK2Z,cAAcxkB,EAAQukB,YAAAA,IAAAA,EAAAA,EAAAA,UAAAA,OAAAA,EAkG7BE,YAAAA,SAAiCtH,GAC3B1C,EAAY0C,IAAOlD,EAAI,GACxBM,EAAQ4C,KAAOA,EAAO+E,EAAQ/E,IAAAA,IAC5BoB,EAAQU,EAAWpU,MACnBmX,EAAQV,EAAYzW,KAAMsS,OAAAA,GAAMzL,OACtCsQ,EAAMxH,GAAaiH,GAAAA,EACnB5C,EAAWN,GACJyD,GAAAA,EAGR0C,YAAAA,SACCnf,EACAiZ,GAAAA,IAOeD,GALWhZ,GAAUA,EAAciV,IAK3C6F,EAAAA,OACP/B,EAAkBC,EAAOC,GAClBgB,OAAAA,EAAyBjB,IAAAA,EAQjCiG,cAAAA,SAAcjX,GAAAA,KACRwT,EAAcxT,GAAAA,EASpB+W,cAAAA,SAAc/W,GACTA,IAAUmV,GACbzI,EAAI,SAEA0F,EAAcpS,GAAAA,EAGpBoX,aAAAA,SAAkCxH,EAASgH,GAAAA,IAGtC3e,EAAAA,IACCA,EAAI2e,EAAQviB,OAAS,EAAG4D,GAAK,EAAGA,IAAK,KACnCof,EAAQT,EAAQ3e,GAAAA,GACI,IAAtBof,EAAMvjB,KAAKO,QAA6B,YAAbgjB,EAAMC,GAAkB,CACtD1H,EAAOyH,EAAMrX,MAAAA,OAMX/H,GAAK,IACR2e,EAAUA,EAAQ/G,MAAM5X,EAAI,QAGvBsf,EAAmB9G,EAAU,WAAW+G,EAAAA,OAC1CxK,EAAQ4C,GAEJ2H,EAAiB3H,EAAMgH,GAGxBtZ,KAAK8Y,QAAQxG,GAAM,SAAC5X,GAAAA,OAC1Buf,EAAiBvf,EAAO4e,OAAAA,EAjL3B,GEZMjF,EAAQ,IAAIqE,EAqBLI,GAAoBzE,EAAMyE,QA+CWzE,IAxCKA,EAAM8E,mBAAmB1K,KAC/E4F,GAQ4BA,EAAMsF,cAAclL,KAAK4F,GAQzBA,EAAMoF,cAAchL,KAAK4F,GAO1BA,EAAMyF,aAAarL,KAAK4F,GAMzBA,EAAMuF,YAAYnL,KAAK4F,GAUvBA,EAAMwF,YAAYpL,KAAK4F,GAAAA,wBE9ElC3a,GAASygB,GAAAA,IAAAA,GACI3hB,EAAAA,GAAAA,WAAS,kBAClCsa,EAC0B,mBAAjBqH,EAA8BA,IAAiBA,GAAAA,MAF9CC,EAAAA,EAAAA,GAMZ,MAAO,CAAC,EAAD,IAELrhB,EAAAA,GAAAA,cAAY,SAACshB,GACwBD,EAAZ,mBAAZC,EAAoCvB,GAAQuB,GACtCvH,EAAOuH,MACvB,cASSC,GACdC,EACAC,EACAC,GAEA,IAAMC,GAAgBC,EAAAA,GAAAA,UAAQ,kBAAM7B,GAAQyB,KAAU,CAACA,IACvD,OAAOK,EAAAA,GAAAA,YAAWF,EAAeF,EAAqBC","sources":["../node_modules/node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../node_modules/@discuzz/data-firestore/src/index.tsx","../node_modules/@firebase/app-check/src/state.ts","../node_modules/@firebase/app-check/src/constants.ts","../node_modules/@firebase/app-check/src/proactive-refresh.ts","../node_modules/@firebase/app-check/src/errors.ts","../node_modules/@firebase/app-check/src/util.ts","../node_modules/@firebase/app-check/src/client.ts","../node_modules/@firebase/app-check/src/indexeddb.ts","../node_modules/@firebase/app-check/src/logger.ts","../node_modules/@firebase/app-check/src/storage.ts","../node_modules/@firebase/app-check/src/debug.ts","../node_modules/@firebase/app-check/src/internal-api.ts","../node_modules/@firebase/app-check/src/factory.ts","../node_modules/@firebase/app-check/src/recaptcha.ts","../node_modules/@firebase/app-check/src/providers.ts","../node_modules/@firebase/app-check/src/api.ts","../node_modules/@firebase/app-check/src/index.ts","../node_modules/immer/src/utils/errors.ts","../node_modules/immer/src/utils/common.ts","../node_modules/immer/src/utils/plugins.ts","../node_modules/immer/src/core/scope.ts","../node_modules/immer/src/core/finalize.ts","../node_modules/immer/src/core/proxy.ts","../node_modules/immer/src/core/immerClass.ts","../node_modules/immer/src/core/current.ts","../node_modules/immer/src/immer.ts","../node_modules/immer/src/utils/env.ts","../node_modules/use-immer/src/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { initializeAppCheck, ReCaptchaV3Provider } from 'firebase/app-check'\nimport {\n  getFirestore,\n  enableIndexedDbPersistence,\n  addDoc as firestoreAddDoc,\n  collection,\n  deleteField,\n  doc,\n  DocumentData,\n  DocumentSnapshot,\n  endAt,\n  getDocs,\n  increment,\n  limit,\n  onSnapshot,\n  orderBy,\n  query,\n  QueryDocumentSnapshot,\n  serverTimestamp,\n  SnapshotOptions,\n  startAfter,\n  updateDoc as firestoreUpdateDoc,\n  QuerySnapshot,\n  where,\n  DocumentReference,\n  CollectionReference,\n\n  deleteDoc as firestoreDeleteDoc,\n  getDoc\n} from 'firebase/firestore'\n\nimport {\n  EMPTY_SYMBOL,\n  AddPostCommand,\n  EditPostCommand,\n  PostListQuery,\n  PostQuery,\n  RemovePostCommand,\n  TogglePostVoteCommand,\n  User,\n  Post as BasePost,\n  fatal,\n  log,\n  PostUpdateResult,\n  RequestState,\n  useAuth,\n  PendingPostListQuery,\n  PendingPost,\n  EditPendingPostCommand,\n  RejectPendingPostCommand,\n  ApprovePendingPostCommand,\n  PendingPostUpdateResult,\n  Auth\n} from '@discuzz/core'\n\nimport { useCallback, useEffect, useState } from 'react'\nimport { useImmer } from 'use-immer'\n\n\nconst PENDING_POST_COLLECTION = 'pending_posts'\nconst POST_COLLECTION = 'posts'\n\ntype Post = BasePost & {\n  snapshot?: DocumentSnapshot\n}\n\nexport default async (config: { [key: string]: string }, auth: Auth) => {\n  const app = auth.data.app\n  const firestore = getFirestore(app)\n\n  try {\n    await enableIndexedDbPersistence(firestore)\n  } catch (error) {\n    console.error('Offline support failed!', error)\n  }\n\n  if (config.recaptchaKey) {\n    initializeAppCheck(app, {\n      provider: new ReCaptchaV3Provider(config.recaptchaKey),\n      isTokenAutoRefreshEnabled: true\n    })\n  }\n\n  const usePostQuery: PostQuery = (id: string) => {\n    const [post, setPost] = useState<Post | null>(null)\n    const [queryState, setQueryState] = useState<RequestState>(\n      RequestState.INITIAL\n    )\n\n    const updatePost = useCallback(\n      (postSnap) => {\n        setPost(postSnap.data()!)\n        setQueryState(RequestState.SUCCESS)\n      },\n      [setPost, setQueryState]\n    )\n\n    useEffect(() => {\n      const postQuery = doc(firestore, POST_COLLECTION, id).withConverter(\n        postConverter\n      )\n\n      setQueryState(RequestState.LOADING)\n      // getDoc(postQuery).then(updatePost)\n      const unsubscribeQuery = onSnapshot(postQuery, updatePost)\n\n      return unsubscribeQuery\n    }, [id])\n\n    return {\n      post,\n      queryState\n    }\n  }\n\n  const usePostListQuery: PostListQuery = (\n    url: string,\n    pagination: number,\n    parent: Post | null = null\n  ) => {\n    const [posts, setPosts] = useImmer<Post[]>([])\n    const [queryState, setQueryState] = useState<RequestState>(\n      RequestState.INITIAL\n    )\n    const [isReachedEnd, toggleReachedEnd] = useState<boolean>(false)\n    const [lastPostDoc, setLastPostDoc] = useState<DocumentSnapshot | null>(null)\n    const [cursor, setCursor] = useState<DocumentSnapshot | null>(null)\n\n    const normalizePosts = useCallback((postsSnap: QuerySnapshot) => {\n      const tmpPosts: Post[] = []\n\n      postsSnap.forEach((postDoc: DocumentData) => {\n        const data = postDoc.data()\n\n        if (data.createdAt) {\n          tmpPosts.push(data)\n        }\n      })\n\n      return tmpPosts\n    }, [])\n\n    const updatePostsFromList = useCallback(\n      (postsSnap: QuerySnapshot) => {\n        const tmpPosts = normalizePosts(postsSnap)\n\n        log('update posts from list', tmpPosts)\n        setPosts((draft) => {\n          for (let i = 0; i < tmpPosts.length; i++) {\n            draft.push(tmpPosts[i])\n          }\n        })\n\n        setQueryState(RequestState.SUCCESS)\n        if (tmpPosts.length < pagination) {\n          toggleReachedEnd(false)\n        } else {\n          toggleReachedEnd(true)\n        }\n      },\n      [setPosts, normalizePosts, setQueryState]\n    )\n    const updatePostsFromSubscriber = useCallback(\n      (postsSnap: QuerySnapshot) => {\n        const tmpPosts = normalizePosts(postsSnap)\n\n        log('update posts from sub', tmpPosts)\n        setPosts((draft) => {\n          for (let i = tmpPosts.length - 1; i >= 0; i--) {\n            const tmpPost = tmpPosts[i]\n            const index = draft.findIndex((post) => post.id === tmpPost.id)\n\n            if (index === -1) {\n              log('add post from sub', tmpPost.id, tmpPost)\n              draft.unshift(tmpPost)\n            } else {\n              log('replace post from sub', tmpPost.id, tmpPost)\n              draft[index] = tmpPost\n            }\n          }\n        })\n      },\n      [setPosts, normalizePosts]\n    )\n    useEffect(() => {\n      if (posts.length > 0 && posts[posts.length - 1].createdAt) {\n        if (\n          lastPostDoc === null ||\n          lastPostDoc.id !== posts[posts.length - 1].id\n        ) {\n          setLastPostDoc(posts[posts.length - 1].snapshot!)\n        }\n      }\n    }, [posts, lastPostDoc])\n\n    useEffect(() => {\n      if (parent === null || parent.replied > 0) {\n        const queryArgs: any[] = [\n          where('url', '==', url),\n          where('parentId', '==', parent ? parent.id : null),\n          orderBy('createdAt', 'desc'),\n          limit(pagination)\n        ]\n\n        if (cursor !== null) {\n          queryArgs.push(startAfter(cursor))\n        }\n\n        setQueryState(RequestState.LOADING)\n\n\n        const postsQuery = query(\n          collection(firestore, POST_COLLECTION),\n          ...queryArgs\n        ).withConverter(postConverter)\n\n        getDocs(postsQuery)\n          .then(updatePostsFromList)\n          .catch((error: Error) => {\n            fatal('query post failed', error)\n            setQueryState(RequestState.FAIL)\n          })\n      } else if (parent.replied === 0) {\n        setQueryState(RequestState.SUCCESS)\n      }\n    }, [url, parent, cursor, updatePostsFromList, setQueryState])\n\n    useEffect(() => {\n      if (queryState === RequestState.SUCCESS) {\n        if (posts.length === 0) {\n          const queryArgs: any[] = [\n            where('url', '==', url),\n            where('parentId', '==', parent ? parent.id : null),\n            where('savedAt', '>', new Date()),\n            orderBy('savedAt', 'desc')\n          ]\n\n          const postsSubscribe = query(\n            collection(firestore, POST_COLLECTION),\n            ...queryArgs\n          ).withConverter(postConverter)\n\n          const unsubscribeQuery = onSnapshot(\n            postsSubscribe,\n            updatePostsFromSubscriber\n          )\n\n          return unsubscribeQuery\n        }\n      }\n      return () => {\n\n      }\n    }, [queryState, posts])\n\n    useEffect(() => {\n      if (lastPostDoc) {\n        const queryArgs: any[] = [\n          where('url', '==', url),\n          where('parentId', '==', parent ? parent.id : null),\n          where('savedAt', '>', new Date()),\n          orderBy('savedAt', 'desc'),\n          endAt(lastPostDoc)\n        ]\n\n        const postsSubscribe = query(\n          collection(firestore, POST_COLLECTION),\n          ...queryArgs\n        ).withConverter(postConverter)\n\n        const unsubscribeQuery = onSnapshot(\n          postsSubscribe,\n          updatePostsFromSubscriber\n        )\n\n        return unsubscribeQuery\n      }\n      return () => {\n\n      }\n    }, [url, parent, lastPostDoc, updatePostsFromSubscriber])\n\n    const loadMore = useCallback(() => {\n      if (posts.length > 0) {\n        setCursor(posts[posts.length - 1].snapshot!)\n      }\n    }, [posts, setCursor])\n\n    return {\n      posts,\n      loadMore,\n      hasMore: parent === null ? isReachedEnd : parent.replied > posts.length,\n      queryState\n    }\n  }\n\n  const postContentsIsInvalid = (contents: string): boolean => {\n    return contents === '' || contents === EMPTY_SYMBOL\n  }\n\n  const updateDoc = async (doc: DocumentReference, data: any) => {\n    log('Update Doc', doc.id, data)\n    return await firestoreUpdateDoc(doc, {\n      ...data,\n      savedAt: serverTimestamp()\n    })\n  }\n\n  const addDoc = async (collection: CollectionReference, data: any) => {\n    log('Add Doc', collection.path, data, collection)\n    return await firestoreAddDoc(collection, {\n      ...data,\n      savedAt: serverTimestamp()\n    })\n  }\n\n  const deleteDoc = async (doc: DocumentReference) => {\n    log('Delete Doc', doc)\n    return await firestoreDeleteDoc(doc)\n  }\n\n  const useAddPostCommand: AddPostCommand = () => {\n    const { user, signInAnonymously } = useAuth()\n\n    const addPost = useCallback(\n      async (contents: string, url?: string, parent?: Post) => {\n        if (postContentsIsInvalid(contents)) {\n          return PostUpdateResult.INVALID\n        }\n\n        let loggedInUser: User = user!\n\n        if (loggedInUser && !loggedInUser.uid) {\n          loggedInUser = await signInAnonymously()\n        }\n\n        const data: any = {\n          paths: parent ? [...parent.paths, parent.id] : [],\n          parentId: parent ? parent.id : null,\n\n          url: parent ? parent.url : url,\n          author: {\n            id: loggedInUser.uid,\n            name: loggedInUser.displayName,\n            photoUrl: loggedInUser.photoURL || ''\n          },\n          contents,\n\n          createdAt: serverTimestamp()\n        }\n\n        if (loggedInUser.canSavePost) {\n          const postData: any = {\n            ...data,\n\n            voted: 1,\n            replied: 0,\n            voters: {\n              [loggedInUser.uid]: 1\n            },\n\n            // savedAt: serverTimestamp(),\n            approvedAt: serverTimestamp()\n          }\n\n          log(\"add post directly\", postData)\n\n          await addDoc(collection(firestore, POST_COLLECTION), postData)\n\n          await updatePostReplied(postData)\n\n          return PostUpdateResult.UPDATED\n        } else {\n          const postData: any = {\n            ...data\n          }\n\n          await addDoc(collection(firestore, PENDING_POST_COLLECTION), postData)\n\n          return PostUpdateResult.PENDING\n        }\n      },\n      [signInAnonymously, user]\n    )\n\n    return addPost\n  }\n\n  const useEditPostCommand: EditPostCommand = () => {\n    const { user } = useAuth()\n\n    const editPost = useCallback(\n      async (post: Post, contents: string) => {\n        if (postContentsIsInvalid(contents)) {\n          return PostUpdateResult.INVALID\n        }\n\n        const data: any = {\n          contents: contents,\n          updatedAt: serverTimestamp()\n        }\n\n        if (user!.canSavePost) {\n          const postDoc = doc(firestore!, POST_COLLECTION, post.id)\n\n          const postData: any = {\n            ...data\n            // savedAt: serverTimestamp()\n          }\n\n          await updateDoc(postDoc, postData)\n\n          return PostUpdateResult.UPDATED\n        } else {\n          const postData: any = {\n            ...data,\n            postId: post.id,\n\n            paths: [],\n            parentId: null,\n            author: {\n              id: user!.uid,\n              name: '',\n              photoUrl: ''\n            }\n          }\n\n          await addDoc(collection(firestore, PENDING_POST_COLLECTION), postData)\n\n          return PostUpdateResult.PENDING\n        }\n      },\n      [user]\n    )\n\n    return editPost\n  }\n\n  const useRemovePostCommand: RemovePostCommand = () => {\n    const removePost = useCallback(\n      async (post: Post) => {\n        const postDoc = doc(firestore, POST_COLLECTION, post.id)\n\n        await updateDoc(postDoc, {\n          contents: '',\n          // savedAt: serverTimestamp(),\n          deletedAt: serverTimestamp()\n        })\n\n        return PostUpdateResult.UPDATED\n      },\n      []\n    )\n\n    return removePost\n  }\n\n  const useTogglePostVoteCommand: TogglePostVoteCommand = () => {\n    const { user, signIn } = useAuth()\n\n    const togglePostVote = useCallback(\n      async (post: Post) => {\n        if (user?.emailVerified) {\n          log('toggle vote', post.id, 'voters', post.voters, 'from', user.uid)\n\n          const postDoc = doc(firestore, POST_COLLECTION, post.id)\n\n          if (post.voters[user!.uid]) {\n            log('remove vote', user.uid)\n\n            await updateDoc(postDoc, {\n              [`voters.${user.uid}`]: deleteField(),\n              // savedAt: serverTimestamp(),\n              voted: increment(-1)\n            })\n          } else {\n            log('add vote', user.uid)\n\n            await updateDoc(postDoc, {\n              [`voters.${user.uid}`]: 1,\n              // savedAt: serverTimestamp(),\n              voted: increment(1)\n            })\n          }\n\n          return PostUpdateResult.UPDATED\n        } else {\n          signIn()\n\n          return PostUpdateResult.INVALID\n        }\n      },\n      [user]\n    )\n\n    return togglePostVote\n  }\n\n  const updatePostReplied = async (\n    data: DocumentData\n  ) => {\n    const parentId =\n      data!.paths.length === 0 ? undefined : data!.paths[data!.paths.length - 1]\n    if (parentId) {\n      log(\"increase post replied\", parentId)\n\n      const parentDoc = doc(firestore, POST_COLLECTION, parentId)\n      await updateDoc(parentDoc, {\n        // savedAt: serverTimestamp(),\n        replied: increment(1)\n      })\n    }\n\n    // const rootParentId = data!.paths.length <= 1 ? undefined : data!.paths[0]\n    // if (rootParentId) {\n    //   const rootParentDoc = doc(firestore, POST_COLLECTION, rootParentId)\n    //   await updateDoc(rootParentDoc, {\n    //     savedAt: serverTimestamp(),\n    //     replied: increment(1)\n    //   })\n    // }\n  }\n\n  const postConverter = {\n    toFirestore(data: Post): DocumentData {\n      const doc: any = {\n        id: data.id,\n        paths: data.paths,\n        parentId: data.parentId,\n\n        url: data.url,\n        author: {\n          id: data.author.id\n        },\n        contents: data.contents,\n\n        voted: data.voted,\n        replied: data.replied,\n        voters: data.voters\n      }\n\n      if (data.author.photoUrl) doc.author.photoUrl = data.author.photoUrl\n      if (data.author.name) doc.author.name = data.author.name\n      if (data.approvedAt) doc.approvedAt = data.approvedAt\n      if (data.savedAt) doc.savedAt = data.savedAt\n      if (data.createdAt) doc.createdAt = data.createdAt\n      if (data.updatedAt) doc.updatedAt = data.updatedAt\n      if (data.deletedAt) doc.deletedAt = data.deletedAt\n\n      return doc\n    },\n    fromFirestore(\n      snapshot: QueryDocumentSnapshot,\n      options: SnapshotOptions\n    ): Post {\n      const data = snapshot.data(options)!\n\n      const post: Post = {\n        id: snapshot.id,\n\n        paths: data.paths,\n        parentId: data.parentId,\n\n        url: data.url,\n        author: {\n          id: data.author.id,\n          name: data.author.name,\n          photoUrl: data.author.photoUrl\n        },\n        contents: data.contents,\n\n        replied: data.replied,\n        voted: data.voted,\n        voters: data.voters,\n\n        snapshot\n      }\n\n      if (data.author.photoUrl) post.author.photoUrl = data.author.photoUrl\n      if (data.paths.length > 0) {\n        post.parentId = data.paths[data.paths.length - 1]\n      }\n\n      if (data.approvedAt) post.approvedAt = data.approvedAt.toDate()\n      if (data.savedAt) post.savedAt = data.savedAt.toDate()\n      if (data.createdAt) post.createdAt = data.createdAt.toDate()\n      if (data.updatedAt) post.updatedAt = data.updatedAt.toDate()\n      if (data.deletedAt) post.deletedAt = data.deletedAt.toDate()\n\n      return post\n    }\n  }\n\n\n\n\n\n\n\n  const usePendingPostQuery: PendingPostListQuery = () => {\n    const { user } = useAuth()\n    const [posts, setPosts] = useState<PendingPost[]>([])\n\n    const updatePosts = useCallback(\n      (postsSnap) => {\n        const posts: PendingPost[] = []\n\n        postsSnap.forEach((postDoc: DocumentData) => {\n          posts.push(postDoc.data())\n        })\n\n        setPosts(posts)\n      },\n      [setPosts]\n    )\n\n    useEffect(() => {\n      if (user && user.isAdmin) {\n        const postsQuery = query(\n          collection(firestore, PENDING_POST_COLLECTION)\n        ).withConverter(pendingPostConverter)\n\n        getDocs(postsQuery).then(updatePosts).catch(console.error)\n        const unsubscribeQuery = onSnapshot(postsQuery, updatePosts)\n\n        return unsubscribeQuery\n      }\n      return () => {\n\n      }\n    }, [user, updatePosts])\n\n    return { pendingPosts: posts }\n  }\n\n  const pendingPostContentsIsInvalid = (contents: string): boolean => {\n    return !contents || contents === EMPTY_SYMBOL\n  }\n\n  const useEditPendingPostCommand: EditPendingPostCommand = () => {\n    const { user } = useAuth()\n\n    const editPendingPost = useCallback(\n      async (pendingPost: PendingPost, contents: string) => {\n        if (pendingPostContentsIsInvalid(contents)) {\n          return PendingPostUpdateResult.FAIL\n        }\n\n        const postDoc = doc(firestore, PENDING_POST_COLLECTION, pendingPost.id)\n        await updateDoc(postDoc, {\n          contents,\n          updatedAt: serverTimestamp()\n        })\n\n        return PendingPostUpdateResult.SUCCESS\n      },\n      [user]\n    )\n\n    return editPendingPost\n  }\n  const useRejectPendingPostCommand: RejectPendingPostCommand = () => {\n    const { user } = useAuth()\n\n    const rejectPendingPost = useCallback(\n      async (pendingPost: PendingPost) => {\n        const postDoc = doc(firestore, PENDING_POST_COLLECTION, pendingPost.id)\n        await deleteDoc(postDoc)\n\n        return PendingPostUpdateResult.SUCCESS\n      },\n      [user]\n    )\n\n    return rejectPendingPost\n  }\n  const useApprovePendingPostCommand: ApprovePendingPostCommand = () => {\n    const { user } = useAuth()\n\n    const approvePendingPost = useCallback(\n      async (pendingPost: PendingPost) => {\n        const pendingPostDoc = doc(\n          firestore,\n          PENDING_POST_COLLECTION,\n          pendingPost.id\n        )\n        const post = await getDoc(pendingPostDoc)\n        const data: any = {\n          approvedAt: serverTimestamp(),\n          savedAt: serverTimestamp()\n        }\n\n        const postData = post.data()\n        if (pendingPost.postId) {\n          const postDoc = doc(firestore, POST_COLLECTION, pendingPost.postId)\n          await updateDoc(postDoc, {\n            ...data,\n            contents: postData!.contents,\n            updatedAt: postData!.updatedAt\n          })\n        } else {\n          await addDoc(collection(firestore, POST_COLLECTION), {\n            ...postData,\n            ...data,\n            replied: 0,\n            voted: 1,\n            voters: {\n              [postData!.author.id]: 1\n            }\n          })\n\n          updatePostReplied(postData!)\n        }\n        await deleteDoc(pendingPostDoc)\n\n        return PendingPostUpdateResult.SUCCESS\n      },\n      [user]\n    )\n\n    return approvePendingPost\n  }\n\n  const pendingPostConverter = {\n    toFirestore(data: PendingPost): DocumentData {\n      const doc: any = {\n        id: data.id,\n        paths: data.paths,\n\n        url: data.url,\n        author: {\n          id: data.author.id\n        },\n        contents: data.contents\n      }\n\n      if (data.author.photoUrl) doc.author.photoUrl = data.author.photoUrl\n      if (data.author.name) doc.author.name = data.author.name\n\n      if (data.postId) doc.postId = data.postId\n      if (data.createdAt) doc.createdAt = data.createdAt\n      if (data.updatedAt) doc.updatedAt = data.updatedAt\n      if (data.deletedAt) doc.deletedAt = data.deletedAt\n\n      return doc\n    },\n    fromFirestore(\n      snapshot: QueryDocumentSnapshot,\n      options: SnapshotOptions\n    ): PendingPost {\n      const data = snapshot.data(options)!\n\n      const post: PendingPost = {\n        id: snapshot.id,\n\n        paths: data.paths,\n\n        url: data.url,\n        author: {\n          id: data.author.id,\n          name: data.author.name,\n          photoUrl: data.author.photoUrl\n        },\n        contents: data.contents\n      }\n\n      if (data.author.photoUrl) post.author.photoUrl = data.author.photoUrl\n      if (data.paths.length > 0) {\n        post.parentId = data.paths[data.paths.length - 1]\n      }\n      if (data.postId) post.postId = data.postId\n      if (data.createdAt) post.createdAt = data.createdAt.toDate()\n      if (data.updatedAt) post.updatedAt = data.updatedAt.toDate()\n      if (data.deletedAt) post.deletedAt = data.deletedAt.toDate()\n\n      return post\n    }\n  }\n\n\n  return {\n    usePostQuery,\n    usePostListQuery,\n    useAddPostCommand,\n    useEditPostCommand,\n    useRemovePostCommand,\n    useTogglePostVoteCommand,\n    usePendingPostQuery,\n    useEditPendingPostCommand,\n    useRejectPendingPostCommand,\n    useApprovePendingPostCommand\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app';\nimport {\n  AppCheckProvider,\n  AppCheckTokenInternal,\n  AppCheckTokenObserver\n} from './types';\nimport { Refresher } from './proactive-refresh';\nimport { Deferred } from '@firebase/util';\nimport { GreCAPTCHA } from './recaptcha';\nexport interface AppCheckState {\n  activated: boolean;\n  tokenObservers: AppCheckTokenObserver[];\n  provider?: AppCheckProvider;\n  token?: AppCheckTokenInternal;\n  cachedTokenPromise?: Promise<AppCheckTokenInternal | undefined>;\n  exchangeTokenPromise?: Promise<AppCheckTokenInternal>;\n  tokenRefresher?: Refresher;\n  reCAPTCHAState?: ReCAPTCHAState;\n  isTokenAutoRefreshEnabled?: boolean;\n}\n\nexport interface ReCAPTCHAState {\n  initialized: Deferred<GreCAPTCHA>;\n  widgetId?: string;\n}\n\nexport interface DebugState {\n  initialized: boolean;\n  enabled: boolean;\n  token?: Deferred<string>;\n}\n\nconst APP_CHECK_STATES = new Map<FirebaseApp, AppCheckState>();\nexport const DEFAULT_STATE: AppCheckState = {\n  activated: false,\n  tokenObservers: []\n};\n\nconst DEBUG_STATE: DebugState = {\n  initialized: false,\n  enabled: false\n};\n\nexport function getState(app: FirebaseApp): AppCheckState {\n  return APP_CHECK_STATES.get(app) || DEFAULT_STATE;\n}\n\nexport function setState(app: FirebaseApp, state: AppCheckState): void {\n  APP_CHECK_STATES.set(app, state);\n}\n\n// for testing only\nexport function clearState(): void {\n  APP_CHECK_STATES.clear();\n  DEBUG_STATE.enabled = false;\n  DEBUG_STATE.token = undefined;\n  DEBUG_STATE.initialized = false;\n}\n\nexport function getDebugState(): DebugState {\n  return DEBUG_STATE;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport const BASE_ENDPOINT =\n  'https://content-firebaseappcheck.googleapis.com/v1beta';\n\nexport const EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaToken';\nexport const EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD =\n  'exchangeRecaptchaEnterpriseToken';\nexport const EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\n\nexport const TOKEN_REFRESH_TIME = {\n  /**\n   * The offset time before token natural expiration to run the refresh.\n   * This is currently 5 minutes.\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n  /**\n   * This is the first retrial wait after an error. This is currently\n   * 30 seconds.\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n  /**\n   * This is the maximum retrial wait, currently 16 minutes.\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n\n/**\n * One day in millis, for certain error code backoffs.\n */\nexport const ONE_DAY = 24 * 60 * 60 * 1000;\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Deferred } from '@firebase/util';\n\n/**\n * Port from auth proactiverefresh.js\n *\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\nexport class Refresher {\n  private pending: Deferred<unknown> | null = null;\n  private nextErrorWaitInterval: number;\n  constructor(\n    private readonly operation: () => Promise<unknown>,\n    private readonly retryPolicy: (error: unknown) => boolean,\n    private readonly getWaitDuration: () => number,\n    private readonly lowerBound: number,\n    private readonly upperBound: number\n  ) {\n    this.nextErrorWaitInterval = lowerBound;\n\n    if (lowerBound > upperBound) {\n      throw new Error(\n        'Proactive refresh lower bound greater than upper bound!'\n      );\n    }\n  }\n\n  start(): void {\n    this.nextErrorWaitInterval = this.lowerBound;\n    this.process(true).catch(() => {\n      /* we don't care about the result */\n    });\n  }\n\n  stop(): void {\n    if (this.pending) {\n      this.pending.reject('cancelled');\n      this.pending = null;\n    }\n  }\n\n  isRunning(): boolean {\n    return !!this.pending;\n  }\n\n  private async process(hasSucceeded: boolean): Promise<void> {\n    this.stop();\n    try {\n      this.pending = new Deferred();\n      await sleep(this.getNextRun(hasSucceeded));\n\n      // Why do we resolve a promise, then immediate wait for it?\n      // We do it to make the promise chain cancellable.\n      // We can call stop() which rejects the promise before the following line execute, which makes\n      // the code jump to the catch block.\n      // TODO: unit test this\n      this.pending.resolve();\n      await this.pending.promise;\n      this.pending = new Deferred();\n      await this.operation();\n\n      this.pending.resolve();\n      await this.pending.promise;\n\n      this.process(true).catch(() => {\n        /* we don't care about the result */\n      });\n    } catch (error) {\n      if (this.retryPolicy(error)) {\n        this.process(false).catch(() => {\n          /* we don't care about the result */\n        });\n      } else {\n        this.stop();\n      }\n    }\n  }\n\n  private getNextRun(hasSucceeded: boolean): number {\n    if (hasSucceeded) {\n      // If last operation succeeded, reset next error wait interval and return\n      // the default wait duration.\n      this.nextErrorWaitInterval = this.lowerBound;\n      // Return typical wait duration interval after a successful operation.\n      return this.getWaitDuration();\n    } else {\n      // Get next error wait interval.\n      const currentErrorWaitInterval = this.nextErrorWaitInterval;\n      // Double interval for next consecutive error.\n      this.nextErrorWaitInterval *= 2;\n      // Make sure next wait interval does not exceed the maximum upper bound.\n      if (this.nextErrorWaitInterval > this.upperBound) {\n        this.nextErrorWaitInterval = this.upperBound;\n      }\n      return currentErrorWaitInterval;\n    }\n  }\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, ErrorMap } from '@firebase/util';\n\nexport const enum AppCheckError {\n  ALREADY_INITIALIZED = 'already-initialized',\n  USE_BEFORE_ACTIVATION = 'use-before-activation',\n  FETCH_NETWORK_ERROR = 'fetch-network-error',\n  FETCH_PARSE_ERROR = 'fetch-parse-error',\n  FETCH_STATUS_ERROR = 'fetch-status-error',\n  STORAGE_OPEN = 'storage-open',\n  STORAGE_GET = 'storage-get',\n  STORAGE_WRITE = 'storage-set',\n  RECAPTCHA_ERROR = 'recaptcha-error',\n  THROTTLED = 'throttled'\n}\n\nconst ERRORS: ErrorMap<AppCheckError> = {\n  [AppCheckError.ALREADY_INITIALIZED]:\n    'You have already called initializeAppCheck() for FirebaseApp {$appName} with ' +\n    'different options. To avoid this error, call initializeAppCheck() with the ' +\n    'same options as when it was originally called. This will return the ' +\n    'already initialized instance.',\n  [AppCheckError.USE_BEFORE_ACTIVATION]:\n    'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. ' +\n    'Call initializeAppCheck() before instantiating other Firebase services.',\n  [AppCheckError.FETCH_NETWORK_ERROR]:\n    'Fetch failed to connect to a network. Check Internet connection. ' +\n    'Original error: {$originalErrorMessage}.',\n  [AppCheckError.FETCH_PARSE_ERROR]:\n    'Fetch client could not parse response.' +\n    ' Original error: {$originalErrorMessage}.',\n  [AppCheckError.FETCH_STATUS_ERROR]:\n    'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n  [AppCheckError.STORAGE_OPEN]:\n    'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n  [AppCheckError.STORAGE_GET]:\n    'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n  [AppCheckError.STORAGE_WRITE]:\n    'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n  [AppCheckError.RECAPTCHA_ERROR]: 'ReCAPTCHA error.',\n  [AppCheckError.THROTTLED]: `Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}`\n};\n\ninterface ErrorParams {\n  [AppCheckError.ALREADY_INITIALIZED]: { appName: string };\n  [AppCheckError.USE_BEFORE_ACTIVATION]: { appName: string };\n  [AppCheckError.FETCH_NETWORK_ERROR]: { originalErrorMessage: string };\n  [AppCheckError.FETCH_PARSE_ERROR]: { originalErrorMessage: string };\n  [AppCheckError.FETCH_STATUS_ERROR]: { httpStatus: number };\n  [AppCheckError.STORAGE_OPEN]: { originalErrorMessage?: string };\n  [AppCheckError.STORAGE_GET]: { originalErrorMessage?: string };\n  [AppCheckError.STORAGE_WRITE]: { originalErrorMessage?: string };\n  [AppCheckError.THROTTLED]: { time: string; httpStatus: number };\n}\n\nexport const ERROR_FACTORY = new ErrorFactory<AppCheckError, ErrorParams>(\n  'appCheck',\n  'AppCheck',\n  ERRORS\n);\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { GreCAPTCHA } from './recaptcha';\nimport { getState } from './state';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { FirebaseApp } from '@firebase/app';\n\nexport function getRecaptcha(\n  isEnterprise: boolean = false\n): GreCAPTCHA | undefined {\n  if (isEnterprise) {\n    return self.grecaptcha?.enterprise;\n  }\n  return self.grecaptcha;\n}\n\nexport function ensureActivated(app: FirebaseApp): void {\n  if (!getState(app).activated) {\n    throw ERROR_FACTORY.create(AppCheckError.USE_BEFORE_ACTIVATION, {\n      appName: app.name\n    });\n  }\n}\n\n/**\n * Copied from https://stackoverflow.com/a/2117523\n */\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16) | 0,\n      v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport function getDurationString(durationInMillis: number): string {\n  const totalSeconds = Math.round(durationInMillis / 1000);\n  const days = Math.floor(totalSeconds / (3600 * 24));\n  const hours = Math.floor((totalSeconds - days * 3600 * 24) / 3600);\n  const minutes = Math.floor(\n    (totalSeconds - days * 3600 * 24 - hours * 3600) / 60\n  );\n  const seconds = totalSeconds - days * 3600 * 24 - hours * 3600 - minutes * 60;\n\n  let result = '';\n  if (days) {\n    result += pad(days) + 'd:';\n  }\n  if (hours) {\n    result += pad(hours) + 'h:';\n  }\n  result += pad(minutes) + 'm:' + pad(seconds) + 's';\n  return result;\n}\n\nfunction pad(value: number): string {\n  if (value === 0) {\n    return '00';\n  }\n  return value >= 10 ? value.toString() : '0' + value;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BASE_ENDPOINT,\n  EXCHANGE_DEBUG_TOKEN_METHOD,\n  EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD,\n  EXCHANGE_RECAPTCHA_TOKEN_METHOD\n} from './constants';\nimport { FirebaseApp } from '@firebase/app';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { Provider } from '@firebase/component';\nimport { AppCheckTokenInternal } from './types';\n\n/**\n * Response JSON returned from AppCheck server endpoint.\n */\ninterface AppCheckResponse {\n  attestationToken: string;\n  // timeToLive\n  ttl: string;\n}\n\ninterface AppCheckRequest {\n  url: string;\n  body: { [key: string]: string };\n}\n\nexport async function exchangeToken(\n  { url, body }: AppCheckRequest,\n  platformLoggerProvider: Provider<'platform-logger'>\n): Promise<AppCheckTokenInternal> {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json'\n  };\n  // If platform logger exists, add the platform info string to the header.\n  const platformLogger = platformLoggerProvider.getImmediate({\n    optional: true\n  });\n  if (platformLogger) {\n    headers['X-Firebase-Client'] = platformLogger.getPlatformInfoString();\n  }\n  const options: RequestInit = {\n    method: 'POST',\n    body: JSON.stringify(body),\n    headers\n  };\n  let response;\n  try {\n    response = await fetch(url, options);\n  } catch (originalError) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_NETWORK_ERROR, {\n      originalErrorMessage: originalError.message\n    });\n  }\n\n  if (response.status !== 200) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_STATUS_ERROR, {\n      httpStatus: response.status\n    });\n  }\n\n  let responseBody: AppCheckResponse;\n  try {\n    // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n    responseBody = await response.json();\n  } catch (originalError) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_PARSE_ERROR, {\n      originalErrorMessage: originalError.message\n    });\n  }\n\n  // Protobuf duration format.\n  // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\n  const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n  if (!match || !match[2] || isNaN(Number(match[1]))) {\n    throw ERROR_FACTORY.create(AppCheckError.FETCH_PARSE_ERROR, {\n      originalErrorMessage:\n        `ttl field (timeToLive) is not in standard Protobuf Duration ` +\n        `format: ${responseBody.ttl}`\n    });\n  }\n  const timeToLiveAsNumber = Number(match[1]) * 1000;\n\n  const now = Date.now();\n  return {\n    token: responseBody.attestationToken,\n    expireTimeMillis: now + timeToLiveAsNumber,\n    issuedAtTimeMillis: now\n  };\n}\n\nexport function getExchangeRecaptchaV3TokenRequest(\n  app: FirebaseApp,\n  reCAPTCHAToken: string\n): AppCheckRequest {\n  const { projectId, appId, apiKey } = app.options;\n\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_token': reCAPTCHAToken\n    }\n  };\n}\n\nexport function getExchangeRecaptchaEnterpriseTokenRequest(\n  app: FirebaseApp,\n  reCAPTCHAToken: string\n): AppCheckRequest {\n  const { projectId, appId, apiKey } = app.options;\n\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_enterprise_token': reCAPTCHAToken\n    }\n  };\n}\n\nexport function getExchangeDebugTokenRequest(\n  app: FirebaseApp,\n  debugToken: string\n): AppCheckRequest {\n  const { projectId, appId, apiKey } = app.options;\n\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      // eslint-disable-next-line\n      debug_token: debugToken\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { AppCheckTokenInternal } from './types';\nconst DB_NAME = 'firebase-app-check-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-app-check-store';\nconst DEBUG_TOKEN_KEY = 'debug-token';\n\nlet dbPromise: Promise<IDBDatabase> | null = null;\nfunction getDBPromise(): Promise<IDBDatabase> {\n  if (dbPromise) {\n    return dbPromise;\n  }\n\n  dbPromise = new Promise((resolve, reject) => {\n    try {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onsuccess = event => {\n        resolve((event.target as IDBOpenDBRequest).result);\n      };\n\n      request.onerror = event => {\n        reject(\n          ERROR_FACTORY.create(AppCheckError.STORAGE_OPEN, {\n            originalErrorMessage: (event.target as IDBRequest).error?.message\n          })\n        );\n      };\n\n      request.onupgradeneeded = event => {\n        const db = (event.target as IDBOpenDBRequest).result;\n\n        // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (e) {\n      reject(\n        ERROR_FACTORY.create(AppCheckError.STORAGE_OPEN, {\n          originalErrorMessage: e.message\n        })\n      );\n    }\n  });\n\n  return dbPromise;\n}\n\nexport function readTokenFromIndexedDB(\n  app: FirebaseApp\n): Promise<AppCheckTokenInternal | undefined> {\n  return read(computeKey(app)) as Promise<AppCheckTokenInternal | undefined>;\n}\n\nexport function writeTokenToIndexedDB(\n  app: FirebaseApp,\n  token: AppCheckTokenInternal\n): Promise<void> {\n  return write(computeKey(app), token);\n}\n\nexport function writeDebugTokenToIndexedDB(token: string): Promise<void> {\n  return write(DEBUG_TOKEN_KEY, token);\n}\n\nexport function readDebugTokenFromIndexedDB(): Promise<string | undefined> {\n  return read(DEBUG_TOKEN_KEY) as Promise<string | undefined>;\n}\n\nasync function write(key: string, value: unknown): Promise<void> {\n  const db = await getDBPromise();\n\n  const transaction = db.transaction(STORE_NAME, 'readwrite');\n  const store = transaction.objectStore(STORE_NAME);\n  const request = store.put({\n    compositeKey: key,\n    value\n  });\n\n  return new Promise((resolve, reject) => {\n    request.onsuccess = _event => {\n      resolve();\n    };\n\n    transaction.onerror = event => {\n      reject(\n        ERROR_FACTORY.create(AppCheckError.STORAGE_WRITE, {\n          originalErrorMessage: (event.target as IDBRequest).error?.message\n        })\n      );\n    };\n  });\n}\n\nasync function read(key: string): Promise<unknown> {\n  const db = await getDBPromise();\n\n  const transaction = db.transaction(STORE_NAME, 'readonly');\n  const store = transaction.objectStore(STORE_NAME);\n  const request = store.get(key);\n\n  return new Promise((resolve, reject) => {\n    request.onsuccess = event => {\n      const result = (event.target as IDBRequest).result;\n\n      if (result) {\n        resolve(result.value);\n      } else {\n        resolve(undefined);\n      }\n    };\n\n    transaction.onerror = event => {\n      reject(\n        ERROR_FACTORY.create(AppCheckError.STORAGE_GET, {\n          originalErrorMessage: (event.target as IDBRequest).error?.message\n        })\n      );\n    };\n  });\n}\n\nfunction computeKey(app: FirebaseApp): string {\n  return `${app.options.appId}-${app.name}`;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from '@firebase/logger';\n\nexport const logger = new Logger('@firebase/app-check');\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { uuidv4 } from './util';\nimport { FirebaseApp } from '@firebase/app';\nimport { isIndexedDBAvailable } from '@firebase/util';\nimport {\n  readDebugTokenFromIndexedDB,\n  readTokenFromIndexedDB,\n  writeDebugTokenToIndexedDB,\n  writeTokenToIndexedDB\n} from './indexeddb';\nimport { logger } from './logger';\nimport { AppCheckTokenInternal } from './types';\n\n/**\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\n */\nexport async function readTokenFromStorage(\n  app: FirebaseApp\n): Promise<AppCheckTokenInternal | undefined> {\n  if (isIndexedDBAvailable()) {\n    let token = undefined;\n    try {\n      token = await readTokenFromIndexedDB(app);\n    } catch (e) {\n      // swallow the error and return undefined\n      logger.warn(`Failed to read token from IndexedDB. Error: ${e}`);\n    }\n    return token;\n  }\n\n  return undefined;\n}\n\n/**\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\n */\nexport function writeTokenToStorage(\n  app: FirebaseApp,\n  token: AppCheckTokenInternal\n): Promise<void> {\n  if (isIndexedDBAvailable()) {\n    return writeTokenToIndexedDB(app, token).catch(e => {\n      // swallow the error and resolve the promise\n      logger.warn(`Failed to write token to IndexedDB. Error: ${e}`);\n    });\n  }\n\n  return Promise.resolve();\n}\n\nexport async function readOrCreateDebugTokenFromStorage(): Promise<string> {\n  /**\n   * Theoretically race condition can happen if we read, then write in 2 separate transactions.\n   * But it won't happen here, because this function will be called exactly once.\n   */\n  let existingDebugToken: string | undefined = undefined;\n  try {\n    existingDebugToken = await readDebugTokenFromIndexedDB();\n  } catch (_e) {\n    // failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\n  }\n\n  if (!existingDebugToken) {\n    // create a new debug token\n    const newToken = uuidv4();\n    // We don't need to block on writing to indexeddb\n    // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\n    // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n    // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n    // You should switch to a different browser that supports indexeddb\n    writeDebugTokenToIndexedDB(newToken).catch(e =>\n      logger.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`)\n    );\n    return newToken;\n  } else {\n    return existingDebugToken;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getDebugState } from './state';\nimport { readOrCreateDebugTokenFromStorage } from './storage';\nimport { Deferred, getGlobal } from '@firebase/util';\n\ndeclare global {\n  // var must be used for global scopes\n  // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#type-checking-for-globalthis\n  // eslint-disable-next-line no-var\n  var FIREBASE_APPCHECK_DEBUG_TOKEN: boolean | string | undefined;\n}\n\nexport function isDebugMode(): boolean {\n  const debugState = getDebugState();\n  return debugState.enabled;\n}\n\nexport async function getDebugToken(): Promise<string> {\n  const state = getDebugState();\n\n  if (state.enabled && state.token) {\n    return state.token.promise;\n  } else {\n    // should not happen!\n    throw Error(`\n            Can't get debug token in production mode.\n        `);\n  }\n}\n\nexport function initializeDebugMode(): void {\n  const globals = getGlobal();\n  const debugState = getDebugState();\n  // Set to true if this function has been called, whether or not\n  // it enabled debug mode.\n  debugState.initialized = true;\n\n  if (\n    typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' &&\n    globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true\n  ) {\n    return;\n  }\n\n  debugState.enabled = true;\n  const deferredToken = new Deferred<string>();\n  debugState.token = deferredToken;\n\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n  } else {\n    deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app';\nimport {\n  AppCheckTokenResult,\n  AppCheckTokenInternal,\n  AppCheckTokenObserver,\n  ListenerType\n} from './types';\nimport { AppCheckTokenListener } from './public-types';\nimport { getState, setState } from './state';\nimport { TOKEN_REFRESH_TIME } from './constants';\nimport { Refresher } from './proactive-refresh';\nimport { ensureActivated } from './util';\nimport { exchangeToken, getExchangeDebugTokenRequest } from './client';\nimport { writeTokenToStorage } from './storage';\nimport { getDebugToken, isDebugMode } from './debug';\nimport { base64, FirebaseError } from '@firebase/util';\nimport { logger } from './logger';\nimport { AppCheckService } from './factory';\nimport { AppCheckError } from './errors';\n\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\nexport const defaultTokenErrorData = { error: 'UNKNOWN_ERROR' };\n\n/**\n * Stringify and base64 encode token error data.\n *\n * @param tokenError Error data, currently hardcoded.\n */\nexport function formatDummyToken(\n  tokenErrorData: Record<string, string>\n): string {\n  return base64.encodeString(\n    JSON.stringify(tokenErrorData),\n    /* webSafe= */ false\n  );\n}\n\n/**\n * This function always resolves.\n * The result will contain an error field if there is any error.\n * In case there is an error, the token field in the result will be populated with a dummy value\n */\nexport async function getToken(\n  appCheck: AppCheckService,\n  forceRefresh = false\n): Promise<AppCheckTokenResult> {\n  const app = appCheck.app;\n  ensureActivated(app);\n\n  const state = getState(app);\n\n  /**\n   * First check if there is a token in memory from a previous `getToken()` call.\n   */\n  let token: AppCheckTokenInternal | undefined = state.token;\n  let error: Error | undefined = undefined;\n\n  /**\n   * If there is no token in memory, try to load token from indexedDB.\n   */\n  if (!token) {\n    // cachedTokenPromise contains the token found in IndexedDB or undefined if not found.\n    const cachedToken = await state.cachedTokenPromise;\n    if (cachedToken && isValid(cachedToken)) {\n      token = cachedToken;\n    }\n  }\n\n  // Return the cached token (from either memory or indexedDB) if it's valid\n  if (!forceRefresh && token && isValid(token)) {\n    return {\n      token: token.token\n    };\n  }\n\n  // Only set to true if this `getToken()` call is making the actual\n  // REST call to the exchange endpoint, versus waiting for an already\n  // in-flight call (see debug and regular exchange endpoint paths below)\n  let shouldCallListeners = false;\n\n  /**\n   * DEBUG MODE\n   * If debug mode is set, and there is no cached token, fetch a new App\n   * Check token using the debug token, and return it directly.\n   */\n  if (isDebugMode()) {\n    // Avoid making another call to the exchange endpoint if one is in flight.\n    if (!state.exchangeTokenPromise) {\n      state.exchangeTokenPromise = exchangeToken(\n        getExchangeDebugTokenRequest(app, await getDebugToken()),\n        appCheck.platformLoggerProvider\n      ).then(token => {\n        state.exchangeTokenPromise = undefined;\n        return token;\n      });\n      shouldCallListeners = true;\n    }\n    const tokenFromDebugExchange: AppCheckTokenInternal =\n      await state.exchangeTokenPromise;\n    // Write debug token to indexedDB.\n    await writeTokenToStorage(app, tokenFromDebugExchange);\n    // Write debug token to state.\n    setState(app, { ...state, token: tokenFromDebugExchange });\n    return { token: tokenFromDebugExchange.token };\n  }\n\n  /**\n   * request a new token\n   */\n  try {\n    // Avoid making another call to the exchange endpoint if one is in flight.\n    if (!state.exchangeTokenPromise) {\n      // state.provider is populated in initializeAppCheck()\n      // ensureActivated() at the top of this function checks that\n      // initializeAppCheck() has been called.\n      state.exchangeTokenPromise = state.provider!.getToken().then(token => {\n        state.exchangeTokenPromise = undefined;\n        return token;\n      });\n      shouldCallListeners = true;\n    }\n    token = await state.exchangeTokenPromise;\n  } catch (e) {\n    if ((e as FirebaseError).code === `appCheck/${AppCheckError.THROTTLED}`) {\n      // Warn if throttled, but do not treat it as an error.\n      logger.warn((e as FirebaseError).message);\n    } else {\n      // `getToken()` should never throw, but logging error text to console will aid debugging.\n      logger.error(e);\n    }\n    // Always save error to be added to dummy token.\n    error = e as FirebaseError;\n  }\n\n  let interopTokenResult: AppCheckTokenResult | undefined;\n  if (!token) {\n    // if token is undefined, there must be an error.\n    // we return a dummy token along with the error\n    interopTokenResult = makeDummyTokenResult(error!);\n  } else {\n    interopTokenResult = {\n      token: token.token\n    };\n    // write the new token to the memory state as well as the persistent storage.\n    // Only do it if we got a valid new token\n    setState(app, { ...state, token });\n    await writeTokenToStorage(app, token);\n  }\n\n  if (shouldCallListeners) {\n    notifyTokenListeners(app, interopTokenResult);\n  }\n  return interopTokenResult;\n}\n\nexport function addTokenListener(\n  appCheck: AppCheckService,\n  type: ListenerType,\n  listener: AppCheckTokenListener,\n  onError?: (error: Error) => void\n): void {\n  const { app } = appCheck;\n  const state = getState(app);\n  const tokenObserver: AppCheckTokenObserver = {\n    next: listener,\n    error: onError,\n    type\n  };\n  setState(app, {\n    ...state,\n    tokenObservers: [...state.tokenObservers, tokenObserver]\n  });\n\n  // Invoke the listener async immediately if there is a valid token\n  // in memory.\n  if (state.token && isValid(state.token)) {\n    const validToken = state.token;\n    Promise.resolve()\n      .then(() => {\n        listener({ token: validToken.token });\n        initTokenRefresher(appCheck);\n      })\n      .catch(() => {\n        /* we don't care about exceptions thrown in listeners */\n      });\n  }\n\n  /**\n   * Wait for any cached token promise to resolve before starting the token\n   * refresher. The refresher checks to see if there is an existing token\n   * in state and calls the exchange endpoint if not. We should first let the\n   * IndexedDB check have a chance to populate state if it can.\n   *\n   * Listener call isn't needed here because cachedTokenPromise will call any\n   * listeners that exist when it resolves.\n   */\n\n  // state.cachedTokenPromise is always populated in `activate()`.\n  void state.cachedTokenPromise!.then(() => initTokenRefresher(appCheck));\n}\n\nexport function removeTokenListener(\n  app: FirebaseApp,\n  listener: AppCheckTokenListener\n): void {\n  const state = getState(app);\n\n  const newObservers = state.tokenObservers.filter(\n    tokenObserver => tokenObserver.next !== listener\n  );\n  if (\n    newObservers.length === 0 &&\n    state.tokenRefresher &&\n    state.tokenRefresher.isRunning()\n  ) {\n    state.tokenRefresher.stop();\n  }\n\n  setState(app, {\n    ...state,\n    tokenObservers: newObservers\n  });\n}\n\n/**\n * Logic to create and start refresher as needed.\n */\nfunction initTokenRefresher(appCheck: AppCheckService): void {\n  const { app } = appCheck;\n  const state = getState(app);\n  // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n  // is not true.\n  let refresher: Refresher | undefined = state.tokenRefresher;\n  if (!refresher) {\n    refresher = createTokenRefresher(appCheck);\n    setState(app, { ...state, tokenRefresher: refresher });\n  }\n  if (!refresher.isRunning() && state.isTokenAutoRefreshEnabled) {\n    refresher.start();\n  }\n}\n\nfunction createTokenRefresher(appCheck: AppCheckService): Refresher {\n  const { app } = appCheck;\n  return new Refresher(\n    // Keep in mind when this fails for any reason other than the ones\n    // for which we should retry, it will effectively stop the proactive refresh.\n    async () => {\n      const state = getState(app);\n      // If there is no token, we will try to load it from storage and use it\n      // If there is a token, we force refresh it because we know it's going to expire soon\n      let result;\n      if (!state.token) {\n        result = await getToken(appCheck);\n      } else {\n        result = await getToken(appCheck, true);\n      }\n\n      // getToken() always resolves. In case the result has an error field defined, it means the operation failed, and we should retry.\n      if (result.error) {\n        throw result.error;\n      }\n    },\n    () => {\n      return true;\n    },\n    () => {\n      const state = getState(app);\n\n      if (state.token) {\n        // issuedAtTime + (50% * total TTL) + 5 minutes\n        let nextRefreshTimeMillis =\n          state.token.issuedAtTimeMillis +\n          (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) *\n            0.5 +\n          5 * 60 * 1000;\n        // Do not allow refresh time to be past (expireTime - 5 minutes)\n        const latestAllowableRefresh =\n          state.token.expireTimeMillis - 5 * 60 * 1000;\n        nextRefreshTimeMillis = Math.min(\n          nextRefreshTimeMillis,\n          latestAllowableRefresh\n        );\n        return Math.max(0, nextRefreshTimeMillis - Date.now());\n      } else {\n        return 0;\n      }\n    },\n    TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT,\n    TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT\n  );\n}\n\nexport function notifyTokenListeners(\n  app: FirebaseApp,\n  token: AppCheckTokenResult\n): void {\n  const observers = getState(app).tokenObservers;\n\n  for (const observer of observers) {\n    try {\n      if (observer.type === ListenerType.EXTERNAL && token.error != null) {\n        // If this listener was added by a 3P call, send any token error to\n        // the supplied error handler. A 3P observer always has an error\n        // handler.\n        observer.error!(token.error);\n      } else {\n        // If the token has no error field, always return the token.\n        // If this is a 2P listener, return the token, whether or not it\n        // has an error field.\n        observer.next(token);\n      }\n    } catch (e) {\n      // Errors in the listener function itself are always ignored.\n    }\n  }\n}\n\nexport function isValid(token: AppCheckTokenInternal): boolean {\n  return token.expireTimeMillis - Date.now() > 0;\n}\n\nfunction makeDummyTokenResult(error: Error): AppCheckTokenResult {\n  return {\n    token: formatDummyToken(defaultTokenErrorData),\n    error\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppCheck } from './public-types';\nimport { FirebaseApp, _FirebaseService } from '@firebase/app';\nimport { FirebaseAppCheckInternal, ListenerType } from './types';\nimport {\n  getToken,\n  addTokenListener,\n  removeTokenListener\n} from './internal-api';\nimport { Provider } from '@firebase/component';\nimport { getState } from './state';\n\n/**\n * AppCheck Service class.\n */\nexport class AppCheckService implements AppCheck, _FirebaseService {\n  constructor(\n    public app: FirebaseApp,\n    public platformLoggerProvider: Provider<'platform-logger'>\n  ) {}\n  _delete(): Promise<void> {\n    const { tokenObservers } = getState(this.app);\n    for (const tokenObserver of tokenObservers) {\n      removeTokenListener(this.app, tokenObserver.next);\n    }\n    return Promise.resolve();\n  }\n}\n\nexport function factory(\n  app: FirebaseApp,\n  platformLoggerProvider: Provider<'platform-logger'>\n): AppCheckService {\n  return new AppCheckService(app, platformLoggerProvider);\n}\n\nexport function internalFactory(\n  appCheck: AppCheckService\n): FirebaseAppCheckInternal {\n  return {\n    getToken: forceRefresh => getToken(appCheck, forceRefresh),\n    addTokenListener: listener =>\n      addTokenListener(appCheck, ListenerType.INTERNAL, listener),\n    removeTokenListener: listener => removeTokenListener(appCheck.app, listener)\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app';\nimport { getState, setState } from './state';\nimport { Deferred } from '@firebase/util';\nimport { getRecaptcha, ensureActivated } from './util';\n\nexport const RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\nexport const RECAPTCHA_ENTERPRISE_URL =\n  'https://www.google.com/recaptcha/enterprise.js';\n\nexport function initializeV3(\n  app: FirebaseApp,\n  siteKey: string\n): Promise<GreCAPTCHA> {\n  const state = getState(app);\n  const initialized = new Deferred<GreCAPTCHA>();\n\n  setState(app, { ...state, reCAPTCHAState: { initialized } });\n  const divId = makeDiv(app);\n\n  const grecaptcha = getRecaptcha(false);\n  if (!grecaptcha) {\n    loadReCAPTCHAV3Script(() => {\n      const grecaptcha = getRecaptcha(false);\n\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n  return initialized.promise;\n}\nexport function initializeEnterprise(\n  app: FirebaseApp,\n  siteKey: string\n): Promise<GreCAPTCHA> {\n  const state = getState(app);\n  const initialized = new Deferred<GreCAPTCHA>();\n\n  setState(app, { ...state, reCAPTCHAState: { initialized } });\n  const divId = makeDiv(app);\n\n  const grecaptcha = getRecaptcha(true);\n  if (!grecaptcha) {\n    loadReCAPTCHAEnterpriseScript(() => {\n      const grecaptcha = getRecaptcha(true);\n\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n  return initialized.promise;\n}\n\n/**\n * Add listener to render the widget and resolve the promise when\n * the grecaptcha.ready() event fires.\n */\nfunction queueWidgetRender(\n  app: FirebaseApp,\n  siteKey: string,\n  grecaptcha: GreCAPTCHA,\n  container: string,\n  initialized: Deferred<GreCAPTCHA>\n): void {\n  grecaptcha.ready(() => {\n    // Invisible widgets allow us to set a different siteKey for each widget,\n    // so we use them to support multiple apps\n    renderInvisibleWidget(app, siteKey, grecaptcha, container);\n    initialized.resolve(grecaptcha);\n  });\n}\n\n/**\n * Add invisible div to page.\n */\nfunction makeDiv(app: FirebaseApp): string {\n  const divId = `fire_app_check_${app.name}`;\n  const invisibleDiv = document.createElement('div');\n  invisibleDiv.id = divId;\n  invisibleDiv.style.display = 'none';\n\n  document.body.appendChild(invisibleDiv);\n  return divId;\n}\n\nexport async function getToken(app: FirebaseApp): Promise<string> {\n  ensureActivated(app);\n\n  // ensureActivated() guarantees that reCAPTCHAState is set\n  const reCAPTCHAState = getState(app).reCAPTCHAState!;\n  const recaptcha = await reCAPTCHAState.initialized.promise;\n\n  return new Promise((resolve, _reject) => {\n    // Updated after initialization is complete.\n    const reCAPTCHAState = getState(app).reCAPTCHAState!;\n    recaptcha.ready(() => {\n      resolve(\n        // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n        recaptcha.execute(reCAPTCHAState.widgetId!, {\n          action: 'fire_app_check'\n        })\n      );\n    });\n  });\n}\n\n/**\n *\n * @param app\n * @param container - Id of a HTML element.\n */\nfunction renderInvisibleWidget(\n  app: FirebaseApp,\n  siteKey: string,\n  grecaptcha: GreCAPTCHA,\n  container: string\n): void {\n  const widgetId = grecaptcha.render(container, {\n    sitekey: siteKey,\n    size: 'invisible'\n  });\n\n  const state = getState(app);\n\n  setState(app, {\n    ...state,\n    reCAPTCHAState: {\n      ...state.reCAPTCHAState!, // state.reCAPTCHAState is set in the initialize()\n      widgetId\n    }\n  });\n}\n\nfunction loadReCAPTCHAV3Script(onload: () => void): void {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n\nfunction loadReCAPTCHAEnterpriseScript(onload: () => void): void {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_ENTERPRISE_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n\ndeclare global {\n  interface Window {\n    grecaptcha: GreCAPTCHATopLevel | undefined;\n  }\n}\n\nexport interface GreCAPTCHATopLevel extends GreCAPTCHA {\n  enterprise: GreCAPTCHA;\n}\n\nexport interface GreCAPTCHA {\n  ready: (callback: () => void) => void;\n  execute: (siteKey: string, options: { action: string }) => Promise<string>;\n  render: (\n    container: string | HTMLElement,\n    parameters: GreCAPTCHARenderOption\n  ) => string;\n}\n\nexport interface GreCAPTCHARenderOption {\n  sitekey: string;\n  size: 'invisible';\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp, _getProvider } from '@firebase/app';\nimport { Provider } from '@firebase/component';\nimport {\n  FirebaseError,\n  issuedAtTime,\n  calculateBackoffMillis\n} from '@firebase/util';\nimport {\n  exchangeToken,\n  getExchangeRecaptchaEnterpriseTokenRequest,\n  getExchangeRecaptchaV3TokenRequest\n} from './client';\nimport { ONE_DAY } from './constants';\nimport { AppCheckError, ERROR_FACTORY } from './errors';\nimport { CustomProviderOptions } from './public-types';\nimport {\n  getToken as getReCAPTCHAToken,\n  initializeV3 as initializeRecaptchaV3,\n  initializeEnterprise as initializeRecaptchaEnterprise\n} from './recaptcha';\nimport { AppCheckProvider, AppCheckTokenInternal, ThrottleData } from './types';\nimport { getDurationString } from './util';\n\n/**\n * App Check provider that can obtain a reCAPTCHA V3 token and exchange it\n * for an App Check token.\n *\n * @public\n */\nexport class ReCaptchaV3Provider implements AppCheckProvider {\n  private _app?: FirebaseApp;\n  private _platformLoggerProvider?: Provider<'platform-logger'>;\n  /**\n   * Throttle requests on certain error codes to prevent too many retries\n   * in a short time.\n   */\n  private _throttleData: ThrottleData | null = null;\n  /**\n   * Create a ReCaptchaV3Provider instance.\n   * @param siteKey - ReCAPTCHA V3 siteKey.\n   */\n  constructor(private _siteKey: string) {}\n\n  /**\n   * Returns an App Check token.\n   * @internal\n   */\n  async getToken(): Promise<AppCheckTokenInternal> {\n    throwIfThrottled(this._throttleData);\n\n    // Top-level `getToken()` has already checked that App Check is initialized\n    // and therefore this._app and this._platformLoggerProvider are available.\n    const attestedClaimsToken = await getReCAPTCHAToken(this._app!).catch(\n      _e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(AppCheckError.RECAPTCHA_ERROR);\n      }\n    );\n    let result;\n    try {\n      result = await exchangeToken(\n        getExchangeRecaptchaV3TokenRequest(this._app!, attestedClaimsToken),\n        this._platformLoggerProvider!\n      );\n    } catch (e) {\n      if ((e as FirebaseError).code === AppCheckError.FETCH_STATUS_ERROR) {\n        this._throttleData = setBackoff(\n          Number((e as FirebaseError).customData?.httpStatus),\n          this._throttleData\n        );\n        throw ERROR_FACTORY.create(AppCheckError.THROTTLED, {\n          time: getDurationString(\n            this._throttleData.allowRequestsAfter - Date.now()\n          ),\n          httpStatus: this._throttleData.httpStatus\n        });\n      } else {\n        throw e;\n      }\n    }\n    // If successful, clear throttle data.\n    this._throttleData = null;\n    return result;\n  }\n\n  /**\n   * @internal\n   */\n  initialize(app: FirebaseApp): void {\n    this._app = app;\n    this._platformLoggerProvider = _getProvider(app, 'platform-logger');\n    initializeRecaptchaV3(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n\n  /**\n   * @internal\n   */\n  isEqual(otherProvider: unknown): boolean {\n    if (otherProvider instanceof ReCaptchaV3Provider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * App Check provider that can obtain a reCAPTCHA Enterprise token and exchange it\n * for an App Check token.\n *\n * @public\n */\nexport class ReCaptchaEnterpriseProvider implements AppCheckProvider {\n  private _app?: FirebaseApp;\n  private _platformLoggerProvider?: Provider<'platform-logger'>;\n  /**\n   * Throttle requests on certain error codes to prevent too many retries\n   * in a short time.\n   */\n  private _throttleData: ThrottleData | null = null;\n  /**\n   * Create a ReCaptchaEnterpriseProvider instance.\n   * @param siteKey - reCAPTCHA Enterprise score-based site key.\n   */\n  constructor(private _siteKey: string) {}\n\n  /**\n   * Returns an App Check token.\n   * @internal\n   */\n  async getToken(): Promise<AppCheckTokenInternal> {\n    throwIfThrottled(this._throttleData);\n    // Top-level `getToken()` has already checked that App Check is initialized\n    // and therefore this._app and this._platformLoggerProvider are available.\n    const attestedClaimsToken = await getReCAPTCHAToken(this._app!).catch(\n      _e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(AppCheckError.RECAPTCHA_ERROR);\n      }\n    );\n    let result;\n    try {\n      result = await exchangeToken(\n        getExchangeRecaptchaEnterpriseTokenRequest(\n          this._app!,\n          attestedClaimsToken\n        ),\n        this._platformLoggerProvider!\n      );\n    } catch (e) {\n      if ((e as FirebaseError).code === AppCheckError.FETCH_STATUS_ERROR) {\n        this._throttleData = setBackoff(\n          Number((e as FirebaseError).customData?.httpStatus),\n          this._throttleData\n        );\n        throw ERROR_FACTORY.create(AppCheckError.THROTTLED, {\n          time: getDurationString(\n            this._throttleData.allowRequestsAfter - Date.now()\n          ),\n          httpStatus: this._throttleData.httpStatus\n        });\n      } else {\n        throw e;\n      }\n    }\n    // If successful, clear throttle data.\n    this._throttleData = null;\n    return result;\n  }\n\n  /**\n   * @internal\n   */\n  initialize(app: FirebaseApp): void {\n    this._app = app;\n    this._platformLoggerProvider = _getProvider(app, 'platform-logger');\n    initializeRecaptchaEnterprise(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n\n  /**\n   * @internal\n   */\n  isEqual(otherProvider: unknown): boolean {\n    if (otherProvider instanceof ReCaptchaEnterpriseProvider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Custom provider class.\n * @public\n */\nexport class CustomProvider implements AppCheckProvider {\n  private _app?: FirebaseApp;\n\n  constructor(private _customProviderOptions: CustomProviderOptions) {}\n\n  /**\n   * @internal\n   */\n  async getToken(): Promise<AppCheckTokenInternal> {\n    // custom provider\n    const customToken = await this._customProviderOptions.getToken();\n    // Try to extract IAT from custom token, in case this token is not\n    // being newly issued. JWT timestamps are in seconds since epoch.\n    const issuedAtTimeSeconds = issuedAtTime(customToken.token);\n    // Very basic validation, use current timestamp as IAT if JWT\n    // has no `iat` field or value is out of bounds.\n    const issuedAtTimeMillis =\n      issuedAtTimeSeconds !== null &&\n      issuedAtTimeSeconds < Date.now() &&\n      issuedAtTimeSeconds > 0\n        ? issuedAtTimeSeconds * 1000\n        : Date.now();\n\n    return { ...customToken, issuedAtTimeMillis };\n  }\n\n  /**\n   * @internal\n   */\n  initialize(app: FirebaseApp): void {\n    this._app = app;\n  }\n\n  /**\n   * @internal\n   */\n  isEqual(otherProvider: unknown): boolean {\n    if (otherProvider instanceof CustomProvider) {\n      return (\n        this._customProviderOptions.getToken.toString() ===\n        otherProvider._customProviderOptions.getToken.toString()\n      );\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Set throttle data to block requests until after a certain time\n * depending on the failed request's status code.\n * @param httpStatus - Status code of failed request.\n * @param throttleData - `ThrottleData` object containing previous throttle\n * data state.\n * @returns Data about current throttle state and expiration time.\n */\nfunction setBackoff(\n  httpStatus: number,\n  throttleData: ThrottleData | null\n): ThrottleData {\n  /**\n   * Block retries for 1 day for the following error codes:\n   *\n   * 404: Likely malformed URL.\n   *\n   * 403:\n   * - Attestation failed\n   * - Wrong API key\n   * - Project deleted\n   */\n  if (httpStatus === 404 || httpStatus === 403) {\n    return {\n      backoffCount: 1,\n      allowRequestsAfter: Date.now() + ONE_DAY,\n      httpStatus\n    };\n  } else {\n    /**\n     * For all other error codes, the time when it is ok to retry again\n     * is based on exponential backoff.\n     */\n    const backoffCount = throttleData ? throttleData.backoffCount : 0;\n    const backoffMillis = calculateBackoffMillis(backoffCount, 1000, 2);\n    return {\n      backoffCount: backoffCount + 1,\n      allowRequestsAfter: Date.now() + backoffMillis,\n      httpStatus\n    };\n  }\n}\n\nfunction throwIfThrottled(throttleData: ThrottleData | null): void {\n  if (throttleData) {\n    if (Date.now() - throttleData.allowRequestsAfter <= 0) {\n      // If before, throw.\n      throw ERROR_FACTORY.create(AppCheckError.THROTTLED, {\n        time: getDurationString(throttleData.allowRequestsAfter - Date.now()),\n        httpStatus: throttleData.httpStatus\n      });\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AppCheck,\n  AppCheckOptions,\n  AppCheckTokenResult,\n  Unsubscribe,\n  PartialObserver\n} from './public-types';\nimport { ERROR_FACTORY, AppCheckError } from './errors';\nimport { getState, setState, AppCheckState, getDebugState } from './state';\nimport { FirebaseApp, getApp, _getProvider } from '@firebase/app';\nimport { getModularInstance, ErrorFn, NextFn } from '@firebase/util';\nimport { AppCheckService } from './factory';\nimport { AppCheckProvider, ListenerType } from './types';\nimport {\n  getToken as getTokenInternal,\n  addTokenListener,\n  removeTokenListener,\n  isValid,\n  notifyTokenListeners\n} from './internal-api';\nimport { readTokenFromStorage } from './storage';\nimport { getDebugToken, initializeDebugMode, isDebugMode } from './debug';\n\ndeclare module '@firebase/component' {\n  interface NameServiceMapping {\n    'app-check': AppCheckService;\n  }\n}\n\nexport {\n  ReCaptchaV3Provider,\n  CustomProvider,\n  ReCaptchaEnterpriseProvider\n} from './providers';\n\n/**\n * Activate App Check for the given app. Can be called only once per app.\n * @param app - the {@link @firebase/app#FirebaseApp} to activate App Check for\n * @param options - App Check initialization options\n * @public\n */\nexport function initializeAppCheck(\n  app: FirebaseApp = getApp(),\n  options: AppCheckOptions\n): AppCheck {\n  app = getModularInstance(app);\n  const provider = _getProvider(app, 'app-check');\n\n  // Ensure initializeDebugMode() is only called once.\n  if (!getDebugState().initialized) {\n    initializeDebugMode();\n  }\n\n  // Log a message containing the debug token when `initializeAppCheck()`\n  // is called in debug mode.\n  if (isDebugMode()) {\n    // Do not block initialization to get the token for the message.\n    void getDebugToken().then(token =>\n      // Not using logger because I don't think we ever want this accidentally hidden.\n      console.log(\n        `App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`\n      )\n    );\n  }\n\n  if (provider.isInitialized()) {\n    const existingInstance = provider.getImmediate();\n    const initialOptions = provider.getOptions() as unknown as AppCheckOptions;\n    if (\n      initialOptions.isTokenAutoRefreshEnabled ===\n        options.isTokenAutoRefreshEnabled &&\n      initialOptions.provider.isEqual(options.provider)\n    ) {\n      return existingInstance;\n    } else {\n      throw ERROR_FACTORY.create(AppCheckError.ALREADY_INITIALIZED, {\n        appName: app.name\n      });\n    }\n  }\n\n  const appCheck = provider.initialize({ options });\n  _activate(app, options.provider, options.isTokenAutoRefreshEnabled);\n  // If isTokenAutoRefreshEnabled is false, do not send any requests to the\n  // exchange endpoint without an explicit call from the user either directly\n  // or through another Firebase library (storage, functions, etc.)\n  if (getState(app).isTokenAutoRefreshEnabled) {\n    // Adding a listener will start the refresher and fetch a token if needed.\n    // This gets a token ready and prevents a delay when an internal library\n    // requests the token.\n    // Listener function does not need to do anything, its base functionality\n    // of calling getToken() already fetches token and writes it to memory/storage.\n    addTokenListener(appCheck, ListenerType.INTERNAL, () => {});\n  }\n\n  return appCheck;\n}\n\n/**\n * Activate App Check\n * @param app - Firebase app to activate App Check for.\n * @param provider - reCAPTCHA v3 provider or\n * custom token provider.\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\n * refreshes App Check tokens as needed. If undefined, defaults to the\n * value of `app.automaticDataCollectionEnabled`, which defaults to\n * false and can be set in the app config.\n */\nfunction _activate(\n  app: FirebaseApp,\n  provider: AppCheckProvider,\n  isTokenAutoRefreshEnabled?: boolean\n): void {\n  const state = getState(app);\n\n  const newState: AppCheckState = { ...state, activated: true };\n  newState.provider = provider; // Read cached token from storage if it exists and store it in memory.\n  newState.cachedTokenPromise = readTokenFromStorage(app).then(cachedToken => {\n    if (cachedToken && isValid(cachedToken)) {\n      setState(app, { ...getState(app), token: cachedToken });\n      // notify all listeners with the cached token\n      notifyTokenListeners(app, { token: cachedToken.token });\n    }\n    return cachedToken;\n  });\n\n  // Use value of global `automaticDataCollectionEnabled` (which\n  // itself defaults to false if not specified in config) if\n  // `isTokenAutoRefreshEnabled` param was not provided by user.\n  newState.isTokenAutoRefreshEnabled =\n    isTokenAutoRefreshEnabled === undefined\n      ? app.automaticDataCollectionEnabled\n      : isTokenAutoRefreshEnabled;\n\n  setState(app, newState);\n\n  newState.provider.initialize(app);\n}\n\n/**\n * Set whether App Check will automatically refresh tokens as needed.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\n * refreshes App Check tokens as needed. This overrides any value set\n * during `initializeAppCheck()`.\n * @public\n */\nexport function setTokenAutoRefreshEnabled(\n  appCheckInstance: AppCheck,\n  isTokenAutoRefreshEnabled: boolean\n): void {\n  const app = appCheckInstance.app;\n  const state = getState(app);\n  // This will exist if any product libraries have called\n  // `addTokenListener()`\n  if (state.tokenRefresher) {\n    if (isTokenAutoRefreshEnabled === true) {\n      state.tokenRefresher.start();\n    } else {\n      state.tokenRefresher.stop();\n    }\n  }\n  setState(app, { ...state, isTokenAutoRefreshEnabled });\n}\n/**\n * Get the current App Check token. Attaches to the most recent\n * in-flight request if one is present. Returns null if no token\n * is present and no token requests are in-flight.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param forceRefresh - If true, will always try to fetch a fresh token.\n * If false, will use a cached token if found in storage.\n * @public\n */\nexport async function getToken(\n  appCheckInstance: AppCheck,\n  forceRefresh?: boolean\n): Promise<AppCheckTokenResult> {\n  const result = await getTokenInternal(\n    appCheckInstance as AppCheckService,\n    forceRefresh\n  );\n  if (result.error) {\n    throw result.error;\n  }\n  return { token: result.token };\n}\n\n/**\n * Registers a listener to changes in the token state. There can be more\n * than one listener registered at the same time for one or more\n * App Check instances. The listeners call back on the UI thread whenever\n * the current token associated with this App Check instance changes.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param observer - An object with `next`, `error`, and `complete`\n * properties. `next` is called with an\n * {@link AppCheckTokenResult}\n * whenever the token changes. `error` is optional and is called if an\n * error is thrown by the listener (the `next` function). `complete`\n * is unused, as the token stream is unending.\n *\n * @returns A function that unsubscribes this listener.\n * @public\n */\nexport function onTokenChanged(\n  appCheckInstance: AppCheck,\n  observer: PartialObserver<AppCheckTokenResult>\n): Unsubscribe;\n/**\n * Registers a listener to changes in the token state. There can be more\n * than one listener registered at the same time for one or more\n * App Check instances. The listeners call back on the UI thread whenever\n * the current token associated with this App Check instance changes.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param onNext - When the token changes, this function is called with aa\n * {@link AppCheckTokenResult}.\n * @param onError - Optional. Called if there is an error thrown by the\n * listener (the `onNext` function).\n * @param onCompletion - Currently unused, as the token stream is unending.\n * @returns A function that unsubscribes this listener.\n * @public\n */\nexport function onTokenChanged(\n  appCheckInstance: AppCheck,\n  onNext: (tokenResult: AppCheckTokenResult) => void,\n  onError?: (error: Error) => void,\n  onCompletion?: () => void\n): Unsubscribe;\n/**\n * Wraps `addTokenListener`/`removeTokenListener` methods in an `Observer`\n * pattern for public use.\n */\nexport function onTokenChanged(\n  appCheckInstance: AppCheck,\n  onNextOrObserver:\n    | ((tokenResult: AppCheckTokenResult) => void)\n    | PartialObserver<AppCheckTokenResult>,\n  onError?: (error: Error) => void,\n  /**\n   * NOTE: Although an `onCompletion` callback can be provided, it will\n   * never be called because the token stream is never-ending.\n   * It is added only for API consistency with the observer pattern, which\n   * we follow in JS APIs.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onCompletion?: () => void\n): Unsubscribe {\n  let nextFn: NextFn<AppCheckTokenResult> = () => {};\n  let errorFn: ErrorFn = () => {};\n  if ((onNextOrObserver as PartialObserver<AppCheckTokenResult>).next != null) {\n    nextFn = (\n      onNextOrObserver as PartialObserver<AppCheckTokenResult>\n    ).next!.bind(onNextOrObserver);\n  } else {\n    nextFn = onNextOrObserver as NextFn<AppCheckTokenResult>;\n  }\n  if (\n    (onNextOrObserver as PartialObserver<AppCheckTokenResult>).error != null\n  ) {\n    errorFn = (\n      onNextOrObserver as PartialObserver<AppCheckTokenResult>\n    ).error!.bind(onNextOrObserver);\n  } else if (onError) {\n    errorFn = onError;\n  }\n  addTokenListener(\n    appCheckInstance as AppCheckService,\n    ListenerType.EXTERNAL,\n    nextFn,\n    errorFn\n  );\n  return () => removeTokenListener(appCheckInstance.app, nextFn);\n}\n","/**\n * Firebase App Check\n *\n * @packageDocumentation\n */\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { registerVersion, _registerComponent } from '@firebase/app';\nimport {\n  Component,\n  ComponentType,\n  InstantiationMode\n} from '@firebase/component';\nimport { _AppCheckComponentName } from './public-types';\nimport { factory, internalFactory } from './factory';\nimport { _AppCheckInternalComponentName } from './types';\nimport { name, version } from '../package.json';\n\n// Used by other Firebase packages.\nexport { _AppCheckInternalComponentName };\n\nexport * from './api';\nexport * from './public-types';\n\nconst APP_CHECK_NAME: _AppCheckComponentName = 'app-check';\nconst APP_CHECK_NAME_INTERNAL: _AppCheckInternalComponentName =\n  'app-check-internal';\nfunction registerAppCheck(): void {\n  // The public interface\n  _registerComponent(\n    new Component(\n      APP_CHECK_NAME,\n      container => {\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider('app').getImmediate();\n        const platformLoggerProvider = container.getProvider('platform-logger');\n        return factory(app, platformLoggerProvider);\n      },\n      ComponentType.PUBLIC\n    )\n      .setInstantiationMode(InstantiationMode.EXPLICIT)\n      /**\n       * Initialize app-check-internal after app-check is initialized to make AppCheck available to\n       * other Firebase SDKs\n       */\n      .setInstanceCreatedCallback(\n        (container, _identifier, _appcheckService) => {\n          container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();\n        }\n      )\n  );\n\n  // The internal interface used by other Firebase products\n  _registerComponent(\n    new Component(\n      APP_CHECK_NAME_INTERNAL,\n      container => {\n        const appCheck = container.getProvider('app-check').getImmediate();\n        return internalFactory(appCheck);\n      },\n      ComponentType.PUBLIC\n    ).setInstantiationMode(InstantiationMode.EXPLICIT)\n  );\n\n  registerVersion(name, version);\n}\n\nregisterAppCheck();\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtype,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === Archtype.Map) thing.set(propOrOldValue, value)\n\telse if (t === Archtype.Set) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\trootState: ImmerState,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: ProxyType.ES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: ProxyType.ES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ProxyType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ProxyType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyType,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyType.ProxyObject ||\n\t\tstate.type_ === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE],\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumerable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyType.ES5Object || state.type_ === ProxyType.ES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyType.Set ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyType\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ProxyType.ProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\tstate.copy_![prop] === value &&\n\t\t\t// special case: NaN\n\t\t\ttypeof value !== \"number\" &&\n\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t(value !== undefined || prop in state.copy_)\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyType.ProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtype,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === Archtype.Set ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase Archtype.Map:\n\t\t\treturn new Map(value)\n\t\tcase Archtype.Set:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","import produce, { Draft, nothing, freeze } from \"immer\";\nimport { useState, useReducer, useCallback, useMemo, Dispatch } from \"react\";\n\nexport type Reducer<S = any, A = any> = (\n  draftState: Draft<S>,\n  action: A\n) => void | (S extends undefined ? typeof nothing : S);\nexport type DraftFunction<S> = (draft: Draft<S>) => void;\nexport type Updater<S> = (arg: S | DraftFunction<S>) => void;\nexport type ImmerHook<S> = [S, Updater<S>];\nexport function useImmer<S = any>(initialValue: S | (() => S)): ImmerHook<S>;\n\nexport function useImmer(initialValue: any) {\n  const [val, updateValue] = useState(() =>\n    freeze(\n      typeof initialValue === \"function\" ? initialValue() : initialValue,\n      true\n    )\n  );\n  return [\n    val,\n    useCallback((updater) => {\n      if (typeof updater === \"function\") updateValue(produce(updater));\n      else updateValue(freeze(updater));\n    }, []),\n  ];\n}\n\nexport function useImmerReducer<S = any, A = any>(\n  reducer: Reducer<S, A>,\n  initialState: S,\n  initialAction?: (initial: any) => S\n): [S, Dispatch<A>];\nexport function useImmerReducer(\n  reducer: any,\n  initialState: any,\n  initialAction: any\n) {\n  const cachedReducer = useMemo(() => produce(reducer), [reducer]);\n  return useReducer(cachedReducer, initialState as any, initialAction);\n}\n"],"names":["Symbol","iterator","asyncIterator","config","auth","recaptchaKey","initializeAppCheck","app","provider","ReCaptchaV3Provider","isTokenAutoRefreshEnabled","postContentsIsInvalid","contents","EMPTY_SYMBOL","updateDoc","doc","data","log","id","firestoreUpdateDoc","savedAt","serverTimestamp","addDoc","collection","path","firestoreAddDoc","deleteDoc","firestoreDeleteDoc","updatePostReplied","parentId","paths","length","parentDoc","firestore","replied","increment","postConverter","toFirestore","url","author","voted","voters","photoUrl","name","approvedAt","createdAt","updatedAt","deletedAt","fromFirestore","snapshot","options","post","toDate","pendingPostConverter","postId","usePostQuery","useState","setPost","RequestState","INITIAL","queryState","setQueryState","updatePost","useCallback","postSnap","SUCCESS","useEffect","postQuery","withConverter","LOADING","onSnapshot","usePostListQuery","pagination","parent","useImmer","posts","setPosts","isReachedEnd","toggleReachedEnd","lastPostDoc","setLastPostDoc","cursor","setCursor","normalizePosts","postsSnap","tmpPosts","forEach","postDoc","push","updatePostsFromList","draft","i","updatePostsFromSubscriber","tmpPost","index","findIndex","unshift","queryArgs","where","orderBy","limit","startAfter","postsQuery","query","getDocs","then","catch","error","fatal","FAIL","Date","postsSubscribe","endAt","loadMore","hasMore","useAddPostCommand","useAuth","user","signInAnonymously","loggedInUser","uid","displayName","photoURL","canSavePost","postData","PostUpdateResult","UPDATED","PENDING","INVALID","useEditPostCommand","useRemovePostCommand","useTogglePostVoteCommand","signIn","emailVerified","deleteField","usePendingPostQuery","updatePosts","isAdmin","console","pendingPosts","useEditPendingPostCommand","pendingPost","PendingPostUpdateResult","useRejectPendingPostCommand","useApprovePendingPostCommand","pendingPostDoc","getDoc","getFirestore","body","recover","result","enableIndexedDbPersistence","e","APP_CHECK_STATES","Map","DEFAULT_STATE","activated","tokenObservers","DEBUG_STATE","initialized","enabled","getState","get","setState","state","set","getDebugState","BASE_ENDPOINT","TOKEN_REFRESH_TIME","Refresher","operation","retryPolicy","getWaitDuration","lowerBound","upperBound","pending","this","nextErrorWaitInterval","Error","process","reject","hasSucceeded","stop","sleep","getNextRun","resolve","promise","currentErrorWaitInterval","ms","Promise","setTimeout","ERRORS","ERROR_FACTORY","getRecaptcha","isEnterprise","self","grecaptcha","enterprise","ensureActivated","create","appName","uuidv4","replace","c","r","Math","random","toString","getDurationString","durationInMillis","totalSeconds","round","days","floor","hours","minutes","seconds","pad","value","exchangeToken","platformLoggerProvider","headers","platformLogger","getImmediate","optional","getPlatformInfoString","method","JSON","stringify","fetch","response","originalErrorMessage","message","status","httpStatus","json","responseBody","match","ttl","isNaN","Number","timeToLiveAsNumber","now","token","attestationToken","expireTimeMillis","issuedAtTimeMillis","getExchangeRecaptchaV3TokenRequest","reCAPTCHAToken","projectId","appId","apiKey","getExchangeRecaptchaEnterpriseTokenRequest","getExchangeDebugTokenRequest","debugToken","debug_token","STORE_NAME","DEBUG_TOKEN_KEY","dbPromise","getDBPromise","request","indexedDB","open","onsuccess","event","target","onerror","onupgradeneeded","db","oldVersion","createObjectStore","keyPath","readTokenFromIndexedDB","read","computeKey","writeDebugTokenToIndexedDB","write","readDebugTokenFromIndexedDB","key","transaction","store","objectStore","put","compositeKey","_event","undefined","logger","warn","writeTokenToStorage","writeTokenToIndexedDB","existingDebugToken","newToken","isDebugMode","getDebugToken","initializeDebugMode","globals","debugState","FIREBASE_APPCHECK_DEBUG_TOKEN","deferredToken","readOrCreateDebugTokenFromStorage","defaultTokenErrorData","getToken","appCheck","forceRefresh","cachedTokenPromise","cachedToken","isValid","shouldCallListeners","exchangeTokenPromise","tokenFromDebugExchange","code","interopTokenResult","makeDummyTokenResult","notifyTokenListeners","type","listener","onError","tokenObserver","next","validToken","initTokenRefresher","newObservers","filter","tokenRefresher","isRunning","refresher","nextRefreshTimeMillis","latestAllowableRefresh","min","max","createTokenRefresher","start","observers","observer","tokenErrorData","AppCheckService","RECAPTCHA_URL","RECAPTCHA_ENTERPRISE_URL","initializeV3","siteKey","reCAPTCHAState","divId","makeDiv","queueWidgetRender","onload","script","document","createElement","src","head","appendChild","loadReCAPTCHAV3Script","initializeEnterprise","loadReCAPTCHAEnterpriseScript","container","ready","widgetId","render","sitekey","size","renderInvisibleWidget","invisibleDiv","style","display","recaptcha","_reject","execute","action","_siteKey","_throttleData","throwIfThrottled","getReCAPTCHAToken","_app","_e","attestedClaimsToken","_platformLoggerProvider","setBackoff","customData","time","allowRequestsAfter","initializeRecaptchaV3","otherProvider","ReCaptchaEnterpriseProvider","initializeRecaptchaEnterprise","CustomProvider","_customProviderOptions","customToken","issuedAtTimeSeconds","throttleData","backoffCount","backoffMillis","isInitialized","existingInstance","initialOptions","getOptions","isEqual","initialize","_activate","newState","readTokenFromStorage","automaticDataCollectionEnabled","setTokenAutoRefreshEnabled","appCheckInstance","getTokenInternal","onTokenChanged","onNextOrObserver","onCompletion","nextFn","errorFn","bind","APP_CHECK_NAME_INTERNAL","factory","getProvider","setInstantiationMode","setInstanceCreatedCallback","_identifier","_appcheckService","addTokenListener","removeTokenListener","internalFactory","die","args","msg","map","s","join","isDraft","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","objectCtorString","Array","isArray","DRAFTABLE","isMap","isSet","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","entry","thing","type_","has","prop","prototype","propOrOldValue","t","delete","add","is","x","y","hasMap","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","desc","writable","configurable","enumerable","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","revoke_","revoked_","processResult","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","current","currentImpl","copy","archType","hasChanges_","copyHelper","from","hasSymbol","hasProxies","Reflect","for","getOwnPropertySymbols","getOwnPropertyNames","currentState","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","apply","Immer","recipe","defaultBase","_this","produce","_this2","hasError","arg1","arg2","produceWithPatches","p","ip","patches","inversePatches","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","initialValue","updateValue","updater","useImmerReducer","reducer","initialState","initialAction","cachedReducer","useMemo","useReducer"],"sourceRoot":""}